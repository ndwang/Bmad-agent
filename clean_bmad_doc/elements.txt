###chapter Lattice Elements

A lattice is made up of a collection of elements --- quadrupoles,
bends, etc. This chapter discusses the various types of elements
available in Bmad.

\tt
                             
  AB_Multipole      \refs:ab.m           Mask              \refs:mask       
  AC_Kicker         \refs:ac.kick        Match             \refs:match      
  BeamBeam          \refs:beambeam       Monitor           \refs:monitor    
  Beginning_Ele     \refs:begin.ele      Multipole         \refs:mult       
  Converter         \refs:converter      Null_Ele          \refs:null.ele   
  Crab_Cavity       \refs:crab           Octupole          \refs:oct        
  Custom            \refs:custom         Patch             \refs:patch      
  Drift             \refs:drift          Photon_Fork       \refs:fork       
  E_Gun             \refs:e.gun          Pipe              \refs:monitor    
  Ecollimator       \refs:col            Quadrupole        \refs:quad       
  ElSeparator       \refs:elsep          Rbend             \refs:bend       
  EM_Field          \refs:em.field       Rcollimator       \refs:col        
  Feedback          \refs:feedback       RF_bend           \refs:rf.bend    
  Fiducial          \refs:fiducial       RFcavity          \refs:rfcav      
  Floor_Shift       \refs:floor.ele      Sad_Mult          \refs:sad.mult   
  Foil              \refs:foil           Sbend             \refs:bend       
  Fork              \refs:fork           Sextupole         \refs:sex        
  GKicker           \refs:gkicker        Sol_Quad          \refs:sq         
  HKicker           \refs:hvkicker       Solenoid          \refs:sol        
  Hybrid            \refs:hybrid         Taylor            \refs:taylor     
  Instrument        \refs:monitor        Thick_Multipole   \refs:thick.mult 
  Kicker            \refs:kicker         Undulator         \refs:wiggler    
  Lcavity           \refs:lcav           VKicker           \refs:hvkicker    
  Marker            \refs:mark           Wiggler           \refs:wiggler    
  
 \captionTable of element types suitable for use with charged particles. Also see
Table~\reft:control.classes \labelt:particle.classes

Most element types available in \mad are provided in Bmad.  Additionally, Bmad provides a number
of element types that are not available in \mad.  A word of caution: In some cases where both \mad
and Bmad provide the same element type, there will be an overlap of the attributes available but
the two sets of attributes will not be the same.  The list of element types known to Bmad is shown
in Table~\reft:particle.classes, \reft:photon.classes, and \reft:control.classes.
Table~\reft:particle.classes lists the elements suitable for use with charged particles,
Table~\reft:photon.classes which lists the elements suitable for use with photons, and finally
Table~\reft:control.classes lists the "controller" element types that can be used for parameter
control of other elements. Note that some element types are suitable for both particle and photon
use.

\tt
                                  
  Beginning_Ele      \refs:begin.ele        Lens               \refs:lens        
  Capillary          \refs:capillary      Marker               \refs:mark        
  Crystal            \refs:crystal        Mask                 \refs:mask        
  Custom             \refs:custom         Match                \refs:match       
  Detector           \refs:detector       Monitor              \refs:monitor      
  Diffraction_Plate  \refs:diff.plate     Mirror               \refs:mirror      
  Drift              \refs:drift          Multilayer_Mirror    \refs:multilayer  
  Ecollimator        \refs:col            Patch                \refs:patch       
  Fiducial           \refs:fiducial       Photon_Fork          \refs:fork        
  Floor_Shift        \refs:floor.ele      Photon_Init          \refs:photon.init 
  Fork               \refs:fork           Pipe                 \refs:monitor     
  GKicker            \refs:gkicker        Rcollimator          \refs:col         
  Instrument         \refs:monitor        Sample               \refs:sample      
  
\tt
                
  Group          \refs:group      Overlay       \refs:overlay  
  Girder         \refs:girder     Ramper        \refs:ramper    

For a listing of element attributes for each type of element, see Chapter~.

###section AB_Multipole

An "ab_multipole" is a thin magnetic multipole lens up to 21\St order. The basic difference
between this and a "multipole"  is the input format. See
section~ for how the multipole coefficients are defined.

General "ab_multipole" attributes are:
\tt
  \sl Attribute Class      \s               \sl Attribute Class      \s               
  an, bn multipoles      \refs:multip   Length                     \refs:l       
  Aperture limits            \refs:limit    Offsets \& tilt            \refs:offset  
  Chamber wall               \refs:wall     Reference energy           \refs:energy   
  Custom Attributes          \refs:cust.att Superposition              \refc:super   
  Description strings        \refs:alias    Tracking \& transfer map   \refc:methods 
  Is_on                      \refs:is.on                                               
  
\toffset
See for a full list of element attributes along with a their units.

The length "l" is a fictitious length that is used for synchrotron radiation computations and
affects the longitudinal position of the next element but does not affect any tracking or transfer
map calculations.  The "x_pitch" and "y_pitch" attributes are not used in tracking.

When an "ab_multipole" is superimposed  on a lattice, it is treated as a zero
length element and in this case it is an error for the length of the "ab_multipole" to be set to
a nonzero value.

Unlike a "multipole", an "ab_multipole" will \em not affect the reference orbit if there is
a dipole component.

Example:
  abc: ab_multipole, a2 = 0.034e-2, b3 = 5.7, a11 = 5.6e6/2

###section AC_Kicker

An "ac_kicker" element simulates a time dependent kicker element.

General "ac_kicker" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Is_on                      \refs:is.on   
  Chamber wall               \refs:wall      Length                     \refs:l       
  Custom Attributes          \refs:cust.att  Mag \& Elec multipoles     \refs:multip  
  Description strings        \refs:alias     Offsets, pitches \& tilt   \refs:offset  
  Field Maps                 \refs:fieldmap  Reference energy           \refs:energy   
  Fringe Fields              \refs:fringe    Superposition              \refc:super   
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp    
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "ac_kicker" element are:
  t_offset        = <Real>              ! Time offset of field waveform.
  interpolation   = <switch>            ! cubic (default) or linear.
  amp_vs_time = {(<time1>, <Amp1>), (<time2>, <Amp2>), ...}  ! Field amp vs Time.
  frequencies = {(<freq1>, <Amp1>, <phi1>), 
                              (<freq2>, <Amp2>, <phi2>), ...} ! Freq components.
Note: The "frequencies" attribute phases "phi1", "phi2", "phi3", etc., have units of
"radians/2pi".

An "ac_kicker" element is like a "kicker"  element except that the field
varies in time. The field is calculated in two steps:
* Calculate the field the same as for a "kicker" element .
* Scale the field using the function A(\delta t) (discussed below)
  B(\delta t) = A(\delta t) \, B_0, \qquad E(\delta t) = A(\delta t) \, E_0
where B and E are the applied magnetic and electric fields, and B_0 and E_0 are the fields
as calculated as if the element where a "kicker" ignoring the time dependence.

\delta t = t_eff - t_0 where t_eff is the effective time as discussed in
and t_0 is the value of the "t_offset" attribute.

There are two ways to specify the dimensionless time variation A(\delta t) of the field. One way
is to specify points (A, \delta t) using the "amp_vs_time" attribute. Example:
  mk: ac_kicker, l = 0.3, scale_multipoles = F, b1 = 0.27, t_offset = 3.6e-8,
          amp_vs_time = {(-1.2e-6, 0.02), ... } 
The element in this example is an AC quadrupole kicker. The times (in seconds) must be in ascending
order and no two times may be the same. The method used to interpolate between the time points is
determined by the setting of the "interpolate" parameter which may be one of
  linear      ! Linear interpolation.
  cubic       ! Cubic spline interpolation (default).
For times outside of the range specified by "amp_vs_time", the amplitude will be extrapolated.
For the cubic spline, extrapolation is only permitted over a distance outside the time range equal
to the time difference between an end point and the next nearest point.

The second way to specify the waveform is to specify the frequencies in the spectrum using the
"frequencies" attribute. In this case the amplitude is:
  A(t) = \sum_i \, A_i \, \cos( 2 \, \pi (f_i \, \delta t + \phi_i))
Example:
  mk: ac_kicker, l = 0.3, field_calc = fieldmap, cartesian_map = {...},
          frequencies = {(3.4e6, 0.34, 0.12), ...}, a0_elec = 1e5
When using a frequency spectrum, the "interpolate" attribute is ignored. Note: The units of the
phases "phi" with the "frequencies" attribute are "rad/2pi".

To specify an "amp_vs_time" component after an "ac_kicker" element has been defined, use the
syntax
  name[AMP_VS_TIME(i)%time]      ! Time of i^th point.
  name[AMP_VS_TIME(i)%amp]       ! Amplitude of i^th point.
where "name" is the name of the element and "i" is the index of the point.
To specify a "frequencies" component after an "ac_kicker" element has been defined, use the
syntax
  name[FREQUENCIES(i)%freq]     ! Frequency of i^th spectrum point.
  name[FREQUENCIES(i)%amp]      ! Amplitude of i^th spectrum point.
  name[FREQUENCIES(i)%phi]      ! Phase (rad/2pi) of i^th spectrum point.
Example:
  mk: ac_kicker, amp_vs_time = {(-1.2e-6, 0.02), ... } 
  mk[amp_vs_time(2)%amp] = 0.03  ! Change 2nd point amplitude.

When specifying the time dependent using a set of frequencies, it is generally advisable to use
absolute time tracking . This can be done in the lattice file by setting
  bmad_com[absolute_time_tracking] = T

Note: The calculated field will only obey Maxwell's equations in the limit that the time variation
of the field is "slow":
  \omega \ll \fraccr
where \omega is the characteristic frequency of the field variation, c is the speed of light,
and r is the characteristic size of the "ac_kicker" element. That is, the fields at opposite
ends of the element must be able to "communicate" (which happens at the speed of light) in a time
scale short compared to the time scale of the change in the field.

###section BeamBeam

A "beambeam" element simulates an interaction with an opposing
("strong") beam traveling in the opposite direction. The strong beam
is assumed to be Gaussian in shape. In the "bmad_standard"
calculation the beam--beam kick is computed using the
Bassetti--Erskine complex error function formula\citeb:talman

General "beambeam" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Is_on                      \refs:is.on   
  Chamber wall               \refs:wall     Offsets, pitches \& tilt   \refs:offset  
  Custom Attributes          \refs:cust.att Reference energy           \refs:energy  
  Description strings        \refs:alias    Superposition              \refc:super   
  Is_on                      \refs:is.on    Tracking \& transfer map   \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "beambeam" element are:
  sig_x          = <Real>    ! Horizontal strong beam sigma at the center 
  sig_y          = <Real>    ! Vertical strong beam sigma at the center
  sig_z          = <Real>    ! Strong beam length
  charge         = <Real>    ! Strong beam charge. Default = -1
  n_particle     = <Real>    ! Number of particles in strong beam.
  n_slice        = <Int>     ! Number of strong beam slices
  crab_x1        = <Real>    ! Crabbing linear coefficient.
  crab_x2        = <Real>    ! Crabbing quadratic coefficient.
  crab_x3        = <Real>    ! Crabbing cubic coefficient.
  crab_x4        = <Real>    ! Crabbing 4th order coefficient.
  crab_x5        = <Real>    ! Crabbing 5th order coefficient.
  crab_tilt      = <Real>    ! Crabbing tilt.
  species_strong = <Species> ! Strong beam species
  E_tot_strong   = <Real>    ! Strong beam particle energy
  beta_a_strong  = <Real>    ! Strong beam $a$-mode beta Twiss parameter
  alpha_a_strong = <Real>    ! Strong beam $a$-mode alpha Twiss parameter 
  beta_b_strong  = <Real>    ! Strong beam $b$-mode beta Twiss parameter
  alpha_b_strong = <Real>    ! Strong beam $b$-mode alpha Twiss parameter
  bbi_constant               ! See below. Dependent attribute .
  ks             = <Real>    ! Solenoid strength.
  bs_field       = <Real>    ! Solenoid field strength.
  field_master   = <T/F>     ! Is ks or bs_field value the master ?
  s_beta_ref     = <Real>    ! Reference position of strong beam Twiss.
  z_crossing     = <Real>    ! Weak particle phase space z when strong beam center reaches IP.
  repetition_frequency = <Real>  ! Strong beam repetition rate.

The strength of the strong beam is set by:
  charge * n_particle
The default The default value of "charge" is -1 which indicates that the strong beam has the
opposite charge of the weak beam. The default for "n_particle" is 0.

For historical reasons, the global parameter "parameter[n_part]"  will be used in
place of "n_particle" if "n_particle" has a value of 0.

"sig_z" are the strong beam's longitudinal sigma.  The strong beam is divided up into
"n_slice" equal charge (not equal thickness) slices. Propagation through the strong beam involves
a kick at the charge center of each slice with propagation between slice centers. A solenoid field
can be set for the regions in between the slice centers. The kicks are calculated using the standard
Bassetti--Erskine complex error function formula\citeb:talman. Even though the strong beam can
have a finite "sig_z", the length of the "beambeam" element is zero. This is achieved by
propagating a particle at the beginning and at the end of tracking so that the longitudinal starting
point and ending points are at the "beambeam" element. Documentation of how a particle is tracked
through a "beambeam" element is given in.

The "ks" and "bs_field" parameters are the normalized and unnormalized solenoid strengths
 related through \Eqkqlbp. If the beambeam element is superimposed on top
of a solenoid, the beambeam element will inherit the solenoid field strength from the solenoid
element instead.

The strong beam Twiss parameters "beta_a_strong", "beta_b_strong", "alpha_a_strong", and
"alpha_b_strong" are the Twiss parameters of the strong beam at the s-position given by
"s_twiss_ref". Additionally, "sig_x", "sig_y" are the transverse sigmas of the strong beam
at this point. "S_beta_ref" is measured relative to the position of the"beambeam" element.  If
"beta_a_strong" is zero (the default), the a-mode Twiss parameters as calculated from the
lattice is used. Similarly, if "beta_b_strong" is zero (the default), the b-mode Twiss
parameters as calculated from the lattice is used.  To calculate the sigmas of any given slice,
"sig_x" and "sig_y" are extrapolated using the Twiss parameters at "s_twiss_ref".

The "x_offset", "y_offset", and "z_offset" attributes  are used to offset
the strong beam. The "x_pitch" and "y_pitch" parameters orient the strong beam with respect to
the laboratory coordinate system. This will be give the beam--beam interaction a crossing angle. The
full crossing angle is the angle of the strong beam (set by "x_pitch" and "y_pitch") with
respect to the trajectory of the weak beam centroid. The weak beam centroid orbit will be the closed
orbit if the lattice geometry is closed. If the lattice geometry is open, the weak beam centroid
orbit is determined by the beginning centroid orbit of the weak beam (which can be program
dependent) and details of the lattice between the beginning of the lattice and the "beambeam"
element.

To curve the strong beam centroid to simulate crabbing, the following parameters can be used:
  crab_x1,    crab_x2,     crab_x3
  crab_x4,    crab_x5,     crab_tilt
If "crab_tilt" is zero (the default), the strong beam centroid (x_c, y_c) will have y_c zero
and
  x_c(z) = \textcrab_x1 \cdot z + \textcrab_x2 \cdot z^2 + \textcrab_x3 \cdot z^3 + 
                                    \textcrab_x4 \cdot z^4 + \textcrab_x5 \cdot z^5
where positive x_c and y_c are the same as positive x and positive y for the weak beam and
z is the longitudinal position with respect to the strong beam center with positive z being
towards the head of the strong bunch (and remember that since the strong bunch is going in the
opposite direction, the head of the strong bunch is opposite that of the weak bunch). With a finite
"crab_tilt", the curvature is rotated around the z axis as shown in figure~\reff:tilt.

The "bbi_constant" is a measure of the beam--beam interaction strength.  It is a dependent
variable and is calculated from the equation
  C_bbi = N \, m_e \, r_e / (2 \, \pi \, \gamma \, (\sigma_x + \sigma_y))
In the linear region, near x = y = 0, the 
beam--beam kick is approximately 
  k_x= -4\, \pi \, x \, C_bbi / \sigma_x \CRNO
  k_y= -4\, \pi \, y \, C_bbi / \sigma_y 
and the linear beam--beam tune shift is 
  dQ_x= C_bbi \, \beta_x / \sigma_x \CRNO
  dQ_y= C_bbi \, \beta_y / \sigma_y \CRNO

The "species_strong" and "E_tot_strong" give the particle species and particle energy of the
strong beam. This is only relevant if the velocity of the strong beam is not equal to the velocity
of the weak beam.

The "z_crossing" parameter sets where the center of the strong beam is relative to the plane of the
beambeam element (the IP) at the time when a weak particle with z = 0 is at the IP. For example,
if tracking is done with radiation damping on, the (weak beam) closed orbit will have a finite phase
space z value at the "beambeam" element. To have the weak beam and strong beam centers cross
the plane of the "beambeam" element at the same time, the value of "z_crossing" should be set
to the value of the weak beam closed orbit z at the IP.

When with absolute time tracking  is in use, the "repetition_frequency"
parameter (along with the "z_crossing" parameter) is used to calculate the time that the strong
bunch crosses the plane of the "beambeam" element. Generally, this frequency should be set equal
to the fundamental RF frequency or some harmonic thereof. If this frequency is zero (the default),
Bmad will assume that the repetition frequency is a harmonic of the reference particle oscillation
time so that in this case a particle's phase space z coordinate will be used.

Example:
  bbi: beambeam, sig_x = 3e-3, sig_y = 3e-4, x_offset = 0.05, n_particle = 1.3e9

###section Beginning_Ele

A "beginning_ele" element, named ""BEGINNING"", is placed at the beginning of every branch
 of a lattice to mark the start of the branch. The "beginning_ele" always
has element index 0 . The creation of this "beginning_ele" element is
automatic and it is not permitted to define a lattice with "beginning_ele" elements at any
other position.

The attributes of the "beginning_ele" element in the root branch are are generally set using
"beginning"  statements or line parameter  statements.
[The attributes of other "beginning_ele" elements are set solely with line parameter statements.]

If the first element after the "beginning_ele" element at the start of a branch is reversed
, the "beginning_ele" element will be marked as reversed so that a
reflection patch is not needed in this circumstance.

See for a full list of element attributes.

###section Bends: Rbend and Sbend

"Rbend"s and "sbend"s are dipole bends. The difference is that "rbend" elements use a
Cartesian ("rectangular") coordinate system to describe the shape of the magnet while "sbend"
elements use a polar ("sector") coordinate system. 

For any given "sbend" element it is possible to construct an equivalent "rbend" element that
has the same shape and vice versa. Given this, and to simplify internal bookkeeping, all "rbend"
elements are converted to "sbend" elements when a lattice is read in to a program.  In order to
preserve the information as to whether a bend element was originally specified as an "sbend" or
an "rbend" in the lattice file, all bend elements have a "sub_key" parameter which is
appropriately set when the lattice is parsed. This "sub_key" parameter does not affect tracking and
is only used if a new lattice file is generated by the program.

General "rbend" and "sbend" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section           
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip    
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset   
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap  
  Description strings        \refs:alias     Reference energy           \refs:energy    
  Fringe Fields              \refs:fringe    Superposition              \refc:super    
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp     
  Is_on                      \refs:is.on     Field Maps                 \refs:fieldmap 
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods  
  Length                     \refs:l                                                     
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to "rbend" and "sbend" elements are:
  angle              = <Real>   ! Design bend angle. Dependent var .
  b_field            = <Real>   ! Design field strength (= P_0 g / q) .
  db_field           = <Real>   ! Actual - Design bending field difference .
  b_field_tot                   ! Net field = b_field + db_field. Dependent param .
  b1_gradient        = <Real>   ! Quadrupole field strength .
  b2_gradient        = <Real>   ! Sextupole field strength .
  e1, e2             = <Real>   ! Face angles.
  exact_multipoles   = <Switch> ! Curved coordinate correction? "off" is default.
  fint, fintx        = <Real>   ! Face field integrals.
  g                  = <Real>   ! Design bend strength (= 1/rho).
  dg                 = <Real>   ! Actual - Design bend strength difference .
  g_tot                         ! Net design strength = g + dg Dependent param .
  h1, h2             = <Real>   ! Face curvature.
  hgap, hgapx        = <Real>   ! Pole half gap.
  k1                 = <Real>   ! Quadrupole strength.
  k2                 = <Real>   ! Sextupole strength .
  l                  = <Real>   ! "Length" of bend. See below.
  l_arc              = <Real>   ! Arc length. For "rbend"s only. 
  l_chord            = <Real>   ! Chord length. See.
  l_rectangle        = <Real>   ! "Rectangular" length.
  l_sagitta                     ! Sagittal length. Dependent param .
  ptc_field_geometry  = <Switch> ! See below. Default is "sector".
  ptc_fringe_geometry = <Switch> ! \Srefs:fringe.type
  rho                = <Real>   ! Design bend radius. Dependent param .
  roll               = <Real>   ! See \refs:offset.
  fiducial_pt        = <switch> ! See below. Default is "none".
  field_master       = <T/F>    ! See \refs:field.master.

    \includegraphics[width=1.05\textwidth]rbend-coords.pdf
    \includegraphics[width=1.05\textwidth]sbend-coords.pdf
    \includegraphics[width=1.05\textwidth]sbend-rev.pdf
  
Coordinate systems for (a) normal (non-reversed)"rbend", (b) normal "sbend", and (c)
"reversed sbend" elements. The bends are viewed from "above" (viewed from positive y).
Normal bends have "g", "angle", and "rho" all positive. Reversed bends have "g",
"angle", and "rho" all negative. The face angles "e1" and "e2" are drawn for
"reference_pt" set to "none" or "center". For (a) and (b), as drawn, the "e1" and "e2" face
angles are both positive. For (c), as drawn, "e1" and "e2" are both negative. In all cases,
"L" is positive. Notice that for reversed bends, the x-axis points towards the center of the
bend while for normal bends the x-axis points towards the outside.
  
  %
       angle 
The total design bend angle. A positive "angle" represents a
bend towards negative x values (see \figf:local.coords).
  %
       B_field, dB_field 
The "B_field" parameter is the design magnetic bending field which determines the reference orbit
and the placement of lattice elements downstream from the bend. The "dB_field" parameter is
the difference between the actual ("total") field and the design field. Thus:
  Actual B-field = B_field + dB_field
See the discussion of "g" and "dg" below for more details.
  %
       e1, e2 
The rotation angle of the entrance pole face is "e1" and at the exit face it is "e2". Zero
"e1" and "e2" for an "rbend" gives a rectangular magnet (\figf:rbend). Zero "e1" and
"e2" for an "sbend" gives a wedge shaped magnet (\figf:sbend).  An "sbend" with an
"e1" = "e2" = "angle"/2 is equivalent to an "rbend" with "e1" = "e2" = 0.  This
formula holds for both positive and negative angles. For "rbend" elements, the above discussion
is true if "fiducial_pt" is set to "none" or "center". If "fiducial_pt" is set to
"entrance_end", then the face angles are measured with respect to the entrace coordinates (s_1
x_1).
If the "fiducial_pt" is set to "exit_end", the face angles are measured with respect to
the exit coordinates (s_2, x_2). Thus
  e1(f_pt=none) = e1(f_pt=entrance_end) - angle/2 = e1(f_pt=exit_end) + angle/2
  e2(f_pt=none) = e2(f_pt=entrance_end) + angle/2 = e2(f_pt=exit_end) - angle/2

Note: The correspondence between "e1" and "e2" and the corresponding parameters used in the
SAD program \citeb:sad is:
  e1(Bmad) =  e1(SAD) * angle + ae1(SAD)
  e2(Bmad) =  e2(SAD) * angle + ae2(SAD)
  %
       exact_multipoles 
The "exact_multipoles" switch can be set to one of:
  off                 ! Default
  vertically_pure    
  horizontally_pure  
This switch determines if the multipole fields, both magnetic and electric, and including the
"k1" and "k2" components, are corrected for the finite curvature of the reference orbit in a
bend. See for a discussion of what "vertically" pure versus
"horizontally" pure means. Setting "exact_multipoles" to "vertically_pure" means that the
individual a_n and b_n multipole components are used with the vertically pure solutions
  B = \sum_n = 0^\infty \left[ \fraca_nn+1 \nabla \phi_n^r + \fracb_nn+1 \nabla \phi_n^i \right], \qquad
  E = \sum_n = 0^\infty \left[ \fraca_enn+1 \nabla \phi_n^i + \fracb_enn+1 \nabla \phi_n^r \right]
and if "exact_multipoles" is set to "horizontally_pure" the horizontally pure solutions
\psi_n^r and \psi_n^i are used instead of the vertically pure solutions \phi_n^r and
\phi_n^i.

To use exact multipoles with PTC based tracking , the PTC exact model
tracking must be turned on. That is, in the lattice file set:
  ptc_com[exact_model] = T
With exact model tracking, PTC always assumes that multipole coefficient values correspond to
"horizontally_pure". In this case, Bmad will convert "vertically_pure" to
"horizontally_pure" as needed when passing multipole coefficients to PTC. Note that in
the case where PTC is doing exact model tracking  but the
"exact_multipoles" switch is set to "off", PTC will still be treating the multipoles
as "horizontally_pure" even though Bmad tracking will be treating them as straight
line multipoles. Note: If the bend has an associated electric field, PTC will always be
doing exact modeling.
  %
       fint, fintx,  hgap, hgapx 
The field integrals for the entrance pole face is given by the product of the "fint" and
"hgap" parameters with "hgap" being the half gap between poles at the entrance face
  F_H1 \equiv F_int \, H_gap = \int_pole \! \! ds \, \fracB_y(s) \, (B_y0 - B_y(s))
  2 \, B_y0^2
For the exit pole face there is a similar equation using "fintx" and "hgapx" which defines
F_H2. In the above equation B_y0 is the field in the interior of the dipole. The values of
"fint", "fintx", "hgap", and "hgapx" are never used in isolation when tracking. Only
the values for F_H1 and F_H2 matter.

If "fint" or "fintx" is given without a value then a value of 0.5 is used. If "fint" or
"fintx" is not present, the default value of 0 is used. Note: \mad does not have the "fintx"
and "hgapx" attributes. \mad just assumes that the values are the same for the entrance and exit
faces. For compatibility with \mad, if "fint" is given but "fintx" is not, then "fintx" is
set equal to "fint". Similarly, "hgapx" will be set to "hgap" if "hgapx" is not
given. Note that this setting of "fintx" or "hgapx" using the value of "fint" or "hgap"
will only be done before lattice expansion .

Note: To have an effect, both "fint" and "hgap" (or "fintx" and "hgapx") must be non-zero.

Note: The SAD program uses "fb1+f1" for the entrance fringe and "fb2+f1" for the exit
fringe. The correspondence between the two is
  F_H1 = fint  * hgap  = (fb1 + f1) / 12
  F_H2 = fintx * hgapx = (fb2 + f1) / 12

"fint" and "hgap" can be related to the Enge function which is sometimes used to model the
fringe field. The Enge function is of the form
  B_y(s) = \fracB_y01 + \exp[P(s)]
where
  P(s) = C_0 + C_1 \, s + C_2 \, s^2 + C_3 \, s^3 + \, \ldots
The C_0 term simply shifts where the edge of the bend is. If all the C_n are zero except for
C_0 and C_1 then
  C_1 = \frac12 \,H_gap \, F_int
  %
       fiducial_pt 
The "fiducial_pt" parameter sets a fiducial point which can be used to keep the shape of the bend
constant when, in a program, the parameters "rho", "g", "b_field" or "angle" are varied.
Varying these parameters typically happens when doing machine design. Using a fiducial point can be
helpful when designing a machine usin bend magnets that already exist.

The "fiducial_pt" parameter
has four possible settings:
  none          ! No fiducial point (default).
  entrance_end  ! The entrance point is the fiducial point.
  center        ! The center of the reference curve is the fiducial point.
  exit_end      ! The exit point is the fiducial point.
With "fiducial_pt" set to "none" (the default). The bend shape is not held constant. With the
other three settings, the bend shape will be held constant as discussed in.
With "fiducial_pt" set to "entrance_end", the reference trajectory at the entrance end is held
fixed in both position and orientation with respect to the bend face and "g", "l" and "e2",
along with the other depdendent parameters, are adjusted to both give the desired change in what was
varied (which is one of "rho", "g", "b_field" or "angle") and to keep the shape of the
bend unchanged. See \figf:bend.fid1. Similarly, if "fiducial_pt" is set to "center", the
center of the reference trajectory is held fixed in both position and orientation and if
"fiducial_pt" is set to "exit_end", the exit point is held fixed in both position and
orientation.
  %
       g, dg, rho 
The design bending radius which determines the reference coordinate system is "rho" (see
). "g" = "1/rho" is the curvature function and is proportional to the design
dipole magnetic field. "g" is related to the design magnetic field "B_field" via
  \textg = \fracqp_0 \, \textB_field 
where q is the charge of the reference particle and p_0 is the reference momentum. It is
important to keep in mind that changing "g" will change the design orbit  and
hence will move all downstream lattice elements in space.

The parameter "dg" is the difference between the actual and the design bending strengths. The
relationship between "dg" and "dB_field" is analogous to the relationship between "g" and
"B_field" in \Eqgqpb. The actual ("total") field strength is given by the sum:
  Actual g = g + dg
Changing "dg" leaves the design orbit and the positions of all downstream lattice elements
unchanged but will vary a particle's orbit. One common mistake when designing lattices is to vary
"g" and not "dg" which results in downstream elements moving around. See \Srefs:ex.chicane
for an example.

Note: A positive "g", which will bend particles and the reference orbit in the -x direction
represents a field of opposite sign as the field due a positive "hkick".
  %
       h1, h2 
The attributes "h1" and "h2" are the curvature of the entrance and exit pole faces. They are
present for compatibility with MAD but are not yet implemented in terms of tracking and other
calculations.
  %
       k1, b1_gradient 
The normalized and unnormalized  quadrupole strength. See \Eqsbbb and \eqkqlbp.

  %
       k2, b2_gradient 
The normalized and unnormalized  sextupole strength. See \Eqsbbb and \eqkqlbp.
  %
       l, l_arc, l_chord, l_sagitta  
For compatibility with MAD, for an "rbend", "l" is the chord length and not the arc length as
it is for an "sbend".  After reading in a lattice, Bmad will internally convert all "rbend"s
into "sbend"s, and the "l_chord" attribute of the created "sbend" will be set to the input
"l". The "l" of the created "sbend" will be set to the true path length (see
above). Alternatively for an "rbend", instead of setting "l", the "l_arc" attribute can be
used to set the true arc length. 

For "sbend" elements, "l_chord" will be set to the calculated chord length. For both types of
bends, the "l_sagitta" parameter will be set to the sagitta length (The sagitta is the distance
from the midpoint of the arc to the midpoint of the chord). "l_sagitta" can be negative and will have
the same sign as the "g" parameter.
  %
       l_rectangle 
The "l_rectangle" parameter is the "rectangular" length defined to be the distance between the
entrance and exit points. The coordinate system used for the calculation is defined by the setting
of "fiducial_pt". \figf:rbend shows "l_rectangle" for "fiducial_pt" set to
"entrance_end" (the coordinate system corresponds to the entrance coordinate system of the bend).
In this case, and in the case where "fiducial_pt" is set to "exit_end", the rectangular
length will be \rho \sin\alpha. If "fiducial_pt" is set to "none" or "center",
"l_rectangle" is the same as the chord length.
  %
       ref_tilt 
The "ref_tilt" attribute rotates a bend about the longitudinal axis at the entrance face of the
bend. A bend with "ref_tilt" of \pi/2 and positive "g" bends the element in the -y
direction ("downward"). See \figf:tilt.bend. It is important to understand that "ref_tilt",
unlike the "tilt" attribute of other elements, bends both the reference orbit along with the
physical element. Note that the MAD "tilt" attribute for bends is equivalent to the Bmad
"ref_tilt". Bends in Bmad do not have a "tilt" attribute.

Important! Do not use "ref_tilt" when doing misalignment studies for a machine. Trying to misalign
a dipole by setting "ref_tilt" will affect the positions of all downstream elements! Rather, use the
"roll" parameter.

The difference between "rbend" and "sbend" elements is the way the "l", "e1", and
"e2" attributes are interpreted.  To ease the bookkeeping burden, after reading in a lattice,
Bmad will internally convert all "rbend"s into "sbend"s.  This is done using the following
transformation on "rbend"s:
  l_chord(internal) = l(input)
  l(internal) = 2 * asin(l_chord * g / 2) / g
  e1(internal) = e1(input) + theta / 2
  e2(internal) = e2(input) + theta / 2

The attributes "g", "angle", and "l" are mutually dependent. If any two are specified for
an element Bmad will calculate the appropriate value for the third.  After reading in a lattice,
"angle" is considered the dependent variable so if "l" or "g" is veried, the value of
"angle" will be set to "g * l". if "theta" is varied, "l" will be set accordingly.

Since internally all "rbend"s are converted to "sbend"s, if one wants to vary the "g"
attribute of a bend and still keep the bend rectangular, an overlay  can be
constructed to maintain the proper face angles.  For example:
  l_ch = 0.54
  g_in = 1.52
  l_coef = asin(l_ch * g_in / 2) / g_in
  my_bend: rbend, l = l_ch, g = g_in
  my_overlay: overlay = {my_bend, my_bend[e1]:l_coef, my_bend[e2]:l_coef}, 
                var = {g}, g = g_in
Notice that "l_coef" is just "arc_length/2".

In the local coordinate system , looking from "above" (bend viewed from positive
y), and with "ref_tilt" = 0, a positive "angle" represents a particle rotating clockwise. In
this case. "g" will also be positive. For counterclockwise rotation, both "angle" and "g"
will be negative but the length "l" is always positive. Also, looking from above, a positive
"e1" represents a clockwise rotation of the entrance face and a positive "e2" represents a
counterclockwise rotation of the exit face. This is true irregardless of the sign of "angle" and
"g". Also it is always the case that the pole faces will be parallel when
  e1 + e2 = angle

Example bend specification:
  b03w: sbend, l = 0.6, k1 = 0.003, fint  ! gives fint = fintx = 0.5

"ptc_field_geometry" determines what reference coordinates PTC uses within a bend for calculating
higher order fields. This only affects tracking if PTC is being used and if
"ptc_com[exact_model]" is set to True . Possible values for
"ptc_field_geometry" are:
  sector      ! Default
  straight
For "sector" reference coordinates, the field coordinate reference frame is with respect to the
arc of the reference trajectory. For "straight" coordinates the coordinate reference frame is
with respect to the chord line. For a bend where there are no other fields besides the basic dipole
field, tracking is essentially unaffected.\footnote
  
There will be a small difference due to the fact that with a "straight" geometry tracking uses a
coordinate system with the z-axis along the chord and with a "sector" geometry an integration step
uses the curvilinear coordinate system with the z-axis along the arc of the bend. If the length
of an integration step is made small, this difference will go to zero.
  
When there are quadrupole or higher order fields, the fields are centered about the reference frame
set by "ptc_field_geometry". Since Bmad based tracking does not implement "straight" geometry
tracking, Bmad and PTC tracking will show marked differences when "ptc_field_geometry" is set to
"straight".

###section Capillary

A "capillary" element is a glass tube that is used to focus x-ray
beams.

General "capillary" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Offsets, Pitches \& Tilt   \refs:offset   
  Capillary Wall             \refs:wall     Reference energy           \refs:energy  
  Custom Attributes          \refs:cust.att Tracking \& transfer map   \refc:methods  
  Description strings        \refs:alias                                               
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "capillary" element are:
  critical_angle_factor = <Real>    ! Critical angle * Energy (rad * eV)

The critical angle above which photons striking the capillary surface are
refracted into the capillary material scales as 1/Energy. The
constant of critical angle * energy is given by the "critical_angle_factor".

The inside wall of a capillary is defined using the same syntax used
to define the chamber wall for other elements .

The length of the capillary is a dependent variable and is given by
the value of "s" of the last wall cross-section
.

###section Collimators: Ecollimator and Rcollimator 

An "ecollimator" is a drift with elliptic collimation. An "rcollimator" is a drift
with rectangular collimation.

Alternatively, for defining a collimator with an arbitrary shape, a "mask" element
 may be used.

General "ecollimator" and "rcollimator" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section           
  Aperture limits            \refs:limit    Offsets, Pitches \& Tilt   \refs:offset   
  Chamber wall               \refs:wall     Overlapping Fields         \refs:overlap  
  Custom Attributes          \refs:cust.att Reference energy           \refs:energy   
  Description strings        \refs:alias    Superposition              \refc:super    
  Hkick \& Vkick             \refs:kick     Symplectify                \refs:symp     
  Integration settings       \refs:integ    Field Maps                 \refs:fieldmap 
  Is_on                      \refs:is.on    Tracking \& transfer map   \refc:methods  
  Length                     \refs:l                                                    
  
\toffset

Attributes specific to a "capillary" element are:
  px_aperture_width2 = <real>  ! px aperture half width
  px_aperture_center = <real>  ! px aperture center
  py_aperture_width2 = <real>  ! py aperture half width
  py_aperture_center = <real>  ! py aperture center
  z_aperture_width2  = <real>  ! z aperture half width
  z_aperture_center  = <real>  ! z aperture center
  pz_aperture_width2 = <real>  ! pz aperture half width
  pz_aperture_center = <real>  ! pz aperture center

Note: Collimators are the exception to the rule that the aperture is independent of any "tilt"s.
See for more details. Additionally, the default setting of "offset_moves_aperture"
is "True" for collimators .

Besides the standard aperture settings \refs:limit that can be used to limit x and y phase
space coordinates, collimators can be used to limit the other four phase space coordinates as well.  For
"rcollimator" elements, particles are collimated if "px_aperture_width2" is greater than zero
and
  px < px_aperture_center - px_aperture_width2  or
  px > px_aperture_center + px_aperture_width2
with similar equations for "py", "z", and "pz". For "ecollimator" elements, if
"px_aperture_width2" and "py_aperture_width2" are both nonzero, particles are collimated if
  ((px - px_aperture_center) / px_aperture_width2)^2 + 
        ((py - py_aperture_center) / py_aperture_width2)^2 < 1
If one or both of "px_aperture_width2" or "py_aperture_width2" are zero, the computation is the
same as for an "rcollimator". A similar situation occurs for "z" and "pz". 

Example:
  d21: ecollimator, l = 4.5, x_limit = 0.09, y_limit = 0.05, 
              px_aperture_width2 = 0.3, py_aperture_width = 0.1

###section Converter

A "converter" element represents a target (plate) onto which particles are slammed in order to generate
particles of a different type. For example, a tungsten plate which is bombarded with electrons to
generate positrons.

General "custom" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Is_on                      \refs:is.on   
  Chamber wall               \refs:wall      Length                     \refs:l       
  Custom Attributes          \refs:cust.att  Offsets, pitches \& tilt   \refs:offset  
  Description strings        \refs:alias     Reference energy           \refs:energy   
  Integration settings       \refs:integ     Superposition              \refc:super   
                                               Tracking \& transfer map   \refc:methods  
  
The attributes specific to an "converter" are 
  distribution    = <Struct>    ! Outgoing particle distribution.
  pc_out_min      = <Real>      ! Minimum outgoing particle momentum (eV).
  pc_out_max      = <Real>      ! Maximum outgoing particle momentum (eV).
  angle_out_max   = <Real>      ! Maximum outgoing angle.
  species_out     = <SpeciesID> ! Output species.
  p0c             = <Real>      ! Output ref momentum.
  E_tot           = <Real>      ! Output ref energy. Dependent var .

The species of the outgoing particles is specified by the "species_out" parameter
.

The converter must be the last element in a lattice branch  except for possible
"fork", "photon_fork" or "marker" elements. A "fork" or "photon_fork" element
 after the converter is used to connect to the line containing the elements that come
after the converter Example:
  parameter[particle] = electron
  parameter[geometry] = open
  to_after: fork, to_line = after_cvter
  cvter, species_out = positron, p0c = 3e6, distribution = ...
  pre_linac: line = (..., cvter, to_after)
  after_cvter: line = (...)                ! Everything after the converter.
  after_cvter[beta_a] = 27; after_cvter[beta_b] = 32
  use, pre_linac
The line up to the fork element, "pre_linac", has the converter just before the "fork"
element. The "fork" element, called "to_after", connects to the line named "after_cvter"
which contains all the elements after the converter. The reference particle and reference momentum
for the "after_cvter" line is set to "positron" and 3e6 respectively to agree with the setting
of "species_out" and "p0c" set in the converter element.

Since Bmad cannot calculate the appropriate Twiss and dispersion values after the converter, values
must be set in the lattice file.  Thus, in the above example, the starting beta function at the
beginning of the "after_cvter" line is set to be \beta_a = 27~m and \beta_b = 32~m.

The "p0c" and "E_tot" attributes of the converter set the reference momentum or energy at the
exit end of the converter. At least one of these attributes must be set. If both are set, "E_tot"
is calculated to be consistent with "p0c".

The "distribution" parameter of a "converter" element specifies the distribution of outgoing
particles for a given converter thickness. Multiple "distribution" instances with differing
thicknesses may be present in an element. The actual thickness of the converter will be taken to be
the element's, length "L" parameter. During tracking, the outgoing distribution will be computed
by interpolating between the two distributions that bracket the actual thickness. The exception is
when there is only one"distribution" present. In this case, the calculation will just use that
distribution for the calculation independent of the element length. Example:
cvter: converter, ..., distribution = {
    material = tungsten,      ! Optional. Not used in tracking.
    thickness = 0.003,        ! Converter thickness for this distribution.
    sub_distribution = {...}, ! Distribution at one incoming momentum.
    sub_distribution = {...}, ! Distribution at another incoming momentum.
    ...                       ! etc.
  }
The "material" component is optional and is only for recording the converter material. Each
"distribution" is made up of a number of "sub_distribution" components. Each one specified the
outgoing distribution for a given incoming particle momentum. During tracking, interpolation is used
to compute the distribution appropriate for an incoming particle with a given momentum. It is an
error in the momentum of the incoming particle is outside the range of the momentums specified
in the "sub_distributions". A given "sub_distribution" will look like:
  sub_distribution = {
    pc_in = 3e8,            ! Incoming momentum*c (eV)>
    prob_pc_r = {...},      ! Momentum and radius probability table 
    direction_out = {...},  ! Momentum orientation probability coefs
  }

A "sub_distribution" has three components: The "pc_in" component specifies the incoming
particle momentum appropriate for the "sub_distribution", the "prob_pc_r" component holds a
two-dimensional table of the probability P(p_\txtout, r) (\Eqnnprp), and "direction_out"
holds the coefficients for calculating the outgoing particle direction. "prob_pc_r" look like:
  prob_pc_r = {
    r_values = [0.0, 4.9e-5, 1.25e-4, ...],
    row = {pc_out = 1.55e6, prob = [0.0, 6.1e-6, 1.23e-5, ...]}, 
    row = {pc_out = 3.96e6, prob = [0.0, 1.1e-5, ...]},
    ...                   ! More rows
  }
A "probl_pc_r" has one "r_values" component and multiple "row" components. The
"r_values" component is a vector of radius values for the columns of the probability table.  The
value for the first column is always zero and the radius values are strictly increasing.  Each
"row" component represents one row of the table. Each row has a momentum value "pc_out" in eV
along with a "prob" component which is a vector of probability values. The length of a "prob"
vector is always equal to the length of the "r_values" vector which is the number of columns in
the table. The probability value of the first column is always zero which reflects the fact that
there is vanishing area in an annulus of width dr as r tends to zero.

The "direction_out" component of "sub_distribution" look like:
  direction_out = {
    c_x = {...},
    alpha_x = {...},
    alpha_y = {...},
    beta = {...},
    dxds_min = {...},
    dxds_max = {...},
    dyds_max = {...}
  }
The "c_x", "alpha_x", "alpha_y", and "beta", components of "direction_out" give the
coefficients for calculating c_x, \alpha_x, \alpha_y, and \beta respectively in
\Eqpxsxs. The other three components give, "dxds_min", "dxds_max", and "dyds_max" give
the range for x' and y' over which \Eqpxsxs is valid. By symmetry, "dyds_min" will be equal
to "-dydx_max". The form of all these components is similar. For example:
  dxds_min = {
    fit_1d_r = {pc_out = 1.5e+06, poly = [-2.48, -658.4, -2.26e5, 1.71e+8]},
    fit_1d_r = {pc_out = 3.9e+06, poly = [...]}, 
    ...,
    C = 2.99394,
    fit_2d_pc = {k = 1.96e-8, poly = [1.0, -4.10e-10, 3.7e-16, 2.77e-27]},
    fit_2d_r = {k = 4.2e-4, poly = [-4.50, 400.2, -108985, 9.18e+06]},
  }
Here there are multiple "fit_1d_r" components, one for each fit \Gamma_i fit function
(\Eqgcr).  The "pc_out" sub-component of a "fit_1d_r" component gives the momentum p_i at
which the fit function fits the data and the "poly" sub-component of "fit_1d_r" gives the
polynomial coefficients needed for \Eqgcr. The C, "fit_2d_pc" and "fit_2d_r" components
are used for computing \Xi (\Eqxkpkr). The "k" sub-components of "fit_2d_pc" and
"fit_2d_r" give k_p and k_r respectively in \Eqxkpkr and the "poly" sub-components of
"fit_2d_pc" and "fit_2d_r" give the polynomial coefficients w_n and k_n respectively.

To calculate the distributions and output the appropriate "distribution" structures which then
can be incorporated into a Bmad lattice, there is modeling code that is distributed with
Bmad. Specifically, it is in the directory
  $ACC_ROOT_DIR/util_programs/converter_element_modeling
[See your local Bmad Guru if you don't know how to find this directory.] There is documentation for
running the program in this directory. The distribution modeling is based upon the "Geant"
simulation toolkit for the simulation of the passage of particles through matter.

The mechanics of how Bmad generates outgoing particles is discussed in \Srefs:converter.track.
In a tracking simulation, a single outgoing particle is generated for each incoming particle.  All
outgoing particles will be assigned a "weight" that represent how many actual outgoing particles
a single actual incoming particle will generate. For example, if an actual incoming particle with a
particular momentum would generate, on average, 0.42 particles, the outgoing particle in the
simulation will have a weight of 0.42.  To make simulations more efficient, the "pc_out_min",
"pc_out_max", and "angle_out_max" parameters can be set to restrict the momentum and angle
range of outgoing particles. If the outgoing particles are restricted in momentum or angle, the
weight of the outgoing particles will be appropriately adjusted such that the weighted distribution
of outgoing particles within the momentum and/or angle restricted range is independent of the
whether or not there is are restrictions.  A value of zero (the default) for any one of these
parameters means that that parameter is ignored.

###section Crab_Cavity

A "crab_cavity" is an RF cavity that gives a z-dependent kick. This is useful in colliding beam
machines, where there is a finite crossing angle at the interaction point, to rotate the beams near the IP.

General "crab_cavity" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Length                     \refs:l          
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy      
  Description strings        \refs:alias     Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp       
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods    
  
\toffset
See for a full list of element attributes along with a their units.

The attributes specific to an "crab_cavity" are 
  gradient        = <Real>    ! Accelerating gradient (V/m).
  phi0            = <Real>    ! Phase (rad/2\pi) of the reference particle with 
                              !   respect to the RF. phi0 = 0 is on crest.
  phi0_multipass  = <Real>    ! Phase (rad/2\pi) with respect to a multipass lord .
  rf_frequency    = <Real>    ! RF frequency (Hz).
  harmon          = <Real>    ! Harmonic number
  harmon_master   = <Logic>   ! Is harmon or rf_frequency the dependent var with ref energy changes?
  voltage                     ! Cavity voltage. Dependent attribute .

The Hamiltonian  H_\textcrab for a thin crab cavity is\citeb:crab1:
  H_\textcrab = -r_q \, V\, x \, \sin(k \, t + 2 \, \pi \, \phi_0)
where x and z are particle coordinates, r_q is the charge relative to the reference
particle, V is the "effective" cavity voltage, \phi_0 is a user settable
phase, and k is the wave number
  k = \frac2 \, \pi \, f_\textrfc
Which give kicks of
  \Delta p_x= -\frac1c \, P_0 \, \frac\partial H_\textcrab\partial x = 
    \fracr_q \, Vc \, P_0 \, \sin(k \, t + 2 \, \pi \, \phi_0) \CRNO 
  \Delta E= -\frac\partial H_\textcrab\partial t = 
    r_q \, V \, \, k \, x \, \cos(k \, t + 2 \, \pi \, \phi_0) 
Note: The sign of H_\textcrab used by Authors in the literature is not standardized. Bmad
uses the convention such that a particle with the charge of the reference particle and with z and
V positive will have a positive \Delta p_x.

In the above equations r_q is the relative charge between the reference particle (set by the
"parameter[particle]" parameter in a lattice file) and the particle being tracked through the
cavity. For example, if the reference particle and and the tracked particle are the same, r_q is
unity independent of the type of particle tracked.

The equations of motion can also be derived from analysis of a TM110 cavity mode for particles near
the centerline\citeb:kim. With this mode, the transverse kick is due to the magnetic field and the
longitudinal kick is due to the electric field. Using this, the integrated electric and magnetic
fields needed for spin tracking are:
  \int \! B_y= \frac-Vc \, \sin(k \, z + 2 \, \pi \, \phi_0) \CRNO 
  \int \! E_s=  \beta \, V \, \, k \, x \, \cos(k \, z + 2 \, \pi \, \phi_0) 
where \beta = v/c is the normalized speed of the particle.

###section Crystal

  \includegraphics[width=5in]crystal-ele.pdf
Crystal element geometry.  A) Geometry for Bragg diffraction. The geometry shown is for
"ref_tilt" = 0 (reference trajectory in the x-z plane). The angle \alpha_H
("alpha_angle") is the angle of the H vector with respect to the surface normal hat
n. For \psi ("psi_angle") zero, the incoming reference orbit, the outgoing reference orbit,
hat n, and H are all coplanar. B) Geometry for Laue diffraction. In this case there are
three outgoing beams: The Bragg diffracted beam, the forward diffracted beam, and the undiffracted
beam.

A "crystal" element represents a crystal used for photon diffraction.

General "crystal" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Surface Properties         \refs:surface  
  Custom Attributes          \refs:cust.att Symplectify                \refs:symp    
  Description strings        \refs:alias    Offsets, Pitches \& Tilt   \refs:offset  
  Reference energy           \refs:energy   Tracking \& transfer map   \refc:methods 
  Reflection tables          \refs:reflect                                             
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "crystal" element are:
  b_param            = <Real>       ! b parameter for photons with the reference energy.
  crystal_type       = <String>     ! Crystal material  and reflection plane.
  psi_angle          = <Real>       ! Rotation of H-vector about the surface normal.
  thickness          = <Real>       ! Thickness of crystal for Laue diffraction.
  ref_orbit_follows  = <which_beam> ! Reference orbit aligned with what outgoing beam?
  graze_angle_in     = <Real>       ! Angle between incoming ref orbit and surface.
  graze_angle_out    = <Real>       ! Angle between outgoing ref orbit and surface.

 is_mosaic          = <Logical>    ! Is a mosaic crystal? Default = False
 mosaic_thickness   = <Real>       ! Mosaic element thickness
 mosaic_angle_rms_in_plane  = <Real> ! In-plane mosaic angular half-width.
 mosaic_angle_rms_out_plane = <Real> ! Out-of-plane angular half-width. 

Dependent variables  specific to a "crystal" element are:
  alpha_angle                ! Angle of H-vector with respect to the surface normal.
  bragg_angle                ! Nominal Bragg angle at the reference wave length. 
  bragg_angle_in             ! Incoming grazing angle for Bragg diffraction.
  bragg_angle_out            ! Outgoing grazing angle for Bragg diffraction.
  d_spacing                  ! Lattice plane spacing. 
  darwin_width_pi            ! Darwin width for pi polarized light (radians).
  darwin_width_sigma         ! Darwin width for sigma polarized light (radians).
  dbragg_angle_de            ! Variation of the Bragg angle with energy (radians/eV).
  l                          ! Length of reference orbit.
  pendellosung_period_pi     ! Pendellosung period for pi polarized light.
  pendellosung_period_sigma  ! Pendellosung period for sigma polarized light.
  ref_wavelength             ! Reference wavelength . Dependent attribute .
  ref_cap_gamma              ! \Gamma at the reference wavelength.
  tilt_corr                  ! Tilt correction due to a finite psi_angle.
  v_unitcell                 ! Unit cell volume. 

The "crystal_type" attribute defines the crystal material and diffraction lattice plane. The
syntax is ""ZZZ(ijk)"" where "ZZZ" is the material name and "ijk" are the Miller indices
for the diffraction plane. For example,
  b_cryst1: crystal, crystal_type = "Si(111)", b_param = -1, ...
The atomic formula is case sensitive so, for example, ""SI(111)"" is not acceptable. The list of
known crystal materials is given in. Given the "crystal_type", the spacing
between lattice planes ("d_spacing"), the unit cell volume ("v_unitcell"), and the structure
factor\citeb:batterman values can be computed.

The "b_param" is the standard b asymmetry factor
  b = \frac\sin(\alpha_H + \theta_B)\sin(\alpha_H - \theta_B) 
where \theta_B is the Bragg angle ("bragg_angle") 
  \theta_B = \sin^-1 \left( \frac\lambda2 \, d \right)
and \alpha_H ("alpha_angle") is the angle of the reciprocal lattice H vector with respect
to the surface normal as shown in \figf:crystalA.  If "b_param" is set to -1 then there is
Bragg reflection and "alpha_H" is zero. If "b_param" is set to 1 then there is Laue
diffraction again with "alpha_H" zero. With the orientation shown in \figf:crystalA,
"alpha_H" is positive.

The "thickness" parameter is used with Laue diffraction and mosaic crystals.

The "ref_orbit_follows" parameter sets how the outgoing reference orbit is constructed. This is
only relevant with Laue diffraction.  The possible settings of this parameter are:
  bragg_diffracted      ! Default
  forward_diffracted
  undiffracted
The geometry of this situation is shown in \figf:crystalB. The reference orbit for the
"undiffracted" beam is just a straight line extension of the incoming reference trajectory. This
trajectory is that trajectory that photons whose energy is far from the Bragg condition (that is,
far from the reference energy) will follow. The "forward_diffracted" reference orbit is parallel
to the "undiffracted" trajectory and is the trajectory of the forward diffracted photons whose
energy is the reference energy and whose incoming orbit is on the incoming reference trajectory.
Finally, the "bragg_diffracted" reference orbit (the default) is the backward diffracted orbit.

Note: Changing the setting of "ref_orbit_follows" will change the reference orbit downstream of
the crystal which, in turn, will change the placement all downstream elements.

The value of the element reference orbit length "l" is calculated by Bmad. "L" will be zero
for Bragg diffraction. For Laue diffraction, "l" will depend upon the crystal "thickness" and
the setting of "ref_orbit_follows".

If "psi_angle" is zero, the incoming reference orbit, the outgoing reference orbit, hat n
and H are all coplanar. A non-zero "psi_angle" Rotates the H vector around the +hat
x axis of the "Element Reference Frame" (See \figf:crystalA).

To keep the outgoing reference trajectory independent of the value of "psi_angle", the crystal
will be automatically tilted by the appropriate "tilt correction" "tilt_corr". The calculation
of "tilt_corr" is outlined in. "tilt_corr" will be zero if
"psi_angle" is zero.

The reference trajectory for a Bragg "crystal" is that of a zero length bend
 and hence the length ("l") parameter of a crystal is fixed at zero. If
the "graze_angle_in" and "graze_angle_out" angles are zero (the default), the orientation of
the reference trajectory with respect to the crystal surface is specified by the incoming Bragg
angle "bragg_angle_in" (\theta_g,in) and outgoing Bragg angle "bragg_angle_out"
(\theta_g,out) as shown in \figf:crystalA. These angles are computed from the photon reference
energy and the other crystal parameters such that a photon with the reference energy traveling along
the reference trajectory will be in the center of the Darwin curve . It
is sometimes convenient to be able to specify the angles that the reference trajectory makes with
respect to the crystal independent of the Bragg angles. To do this, set "graze_angle_in" and
"graze_angle_out" to the desired angles.

Notice that due to refraction at the surface, the computed "bragg_angle" from \Eqtsl2d will
deviate slightly from the average of "bragg_angle_in" and "bragg_angle_out".

The reference trajectory in the global coordinate system  is determined by the
value of the "ref_tilt" parameter along with the value of "bragg_angle_in" +
"bragg_angle_out". These bragg angles take into account refraction so that the reference
trajectory downstream of the crystal will be properly centered with respect to the reference
photon. A positive "bragg_angle_in" + "bragg_angle_out" bends the reference trajectory in the
same direction as a positive "g" for a bend element. The

A "crystal" may be offset and pitched (\refs:offset). The incoming local reference coordinates
are used for these misalignments.

When a crystal is bent , the H vector is assumed follow the surface
curvature. That is, it is assumed that the lattice planes are curved by the bending.

Example:
  crystal_ele: crystal, crystal_type = "Si(111)", b_param = -1

The "darwin_width_sigma" and "darwin_width_pi" parameters are the computed Darwin width, in
radians, for sigma and pi polarized light respectively. Here the Darwin width d\theta_D is defined
as the width at the \eta = \pm 1 points (cf.~Batterman\citeb:batterman Eq (32))
  d\theta_D = \frac2 \, \Gamma \, |P| \, \textRe \! \left( [F_H \, F_\Hbar]^1/2 \right)
                 |b|^1/2 \, \sin\theta_tot
where
  \theta_tot = bragg_angle_in + bragg_angle_out 

The "pendellosung_period_sigma" and "pendellosung_period_pi" are the pendellosung periods for
Laue diffraction. If the crystal is set up for Bragg diffraction then the values for these
parameters will be set to zero.

The "dbragg_angle_de" parameter is the variation in Bragg angle with respect to the photon energy
and is given by the formula
  \fracd\theta_BdE = -\frac\lambda2 \, d \, E \, \cos( \theta_B )

See Section~ for an example lattice that can be used to simulate a Rowland circle
spectrometer.

%----------------
###subsection Mosaic Crystal

A mosaic crystal is an idealized model of an imperfect crystal imagined to consist of numerous
small perfect crystals called crystallites that are randomly misoriented. Currently, mosaic crystals
can only be used with Laue orientation. Mosaic crystals are parameterized by four element
parameters:
\beginexample
 is_mosaic          = <Logical>    ! Is a mosaic crystal? Default = False
 mosaic_thickness   = <Real>       ! Mosaic element thickness
 mosaic_angle_rms_in_plane  = <Real> ! In-plane angular half-width. 
 mosaic_angle_rms_out_plane = <Real> ! Out-of-plane angular half-width. 
\endexample
The "is_mosaic" logical is used to toggle between mosaic and non-mosaic tracking. Tracking in a
mosaic is detailed in Section~. The angular spread of the orientation of the
crystallites in the diffraction plane is given by "mosaic_angle_rms_in_plane". This
corresponds to rotations around the y-axis in the element reference frame in \figf:crystalB. The
"mosaic_angle_rms_out_plane" parameter gives the angular spread of the crystallites for 

The thickness of the mosaic is given by the "mosaic_thickness" parameter. For "Laue"
diffraction ("b_param" > 0), the actual mosaic thickness T_m used is adjusted so that there is
an integer number of mosaic layers. That is
\beginequation
 T_m(\textin simulation = \fracT\textnint (T/T_m)
\endequation
where T is the crystal thickness and "nint" is the nearest integer function.

###section Custom

A "custom" element is an element whose properties are defined outside of the standard Bmad
subroutine library. That is, to use a custom element, some programmer must write the appropriate
custom routines which are then linked with the Bmad subroutines into a program. Bmad will call the
custom routines at the appropriate time to do tracking, transfer matrix calculations, etc. See the
programmer who wrote the custom routines for more details! See on how to write
custom routines.

General "custom" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Is_on                      \refs:is.on   
  Chamber wall               \refs:wall      Length                     \refs:l       
  Custom Attributes          \refs:cust.att  Offsets, pitches \& tilt   \refs:offset  
  Description strings        \refs:alias     Reference energy           \refs:energy   
  Field Maps                 \refs:fieldmap  Superposition              \refc:super   
  Fringe fields              \refs:fringe    Symplectify                \refs:symp    
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

As an alternative to defining a custom element, standard elements can
be "customized" by setting one or more of the following attributes
to "custom":
  tracking_method      
  mat6_calc_method     
  field_calc           
  aperture_type        

As with a custom element, setting one of these attributes to
"custom" necessitates the use of custom code to implement the
corresponding calculation.

Attributes specific to a "custom" element are
  val1, ..., val12 = <Real>  ! Custom values 
  delta_e_ref      = <Real>  ! Change in energy.

"delta_e_ref" is the energy gain of the  particle
between the starting edge of the element and the ending edge.

Example:
  c1: custom, l = 3, val4 = 5.6, val12 = 0.9, descrip = "params.dat"
In this example the "descrip" string is being used to specify a
file that contains parameters for the element.

###section Detector

A "detector" element is used to detect particles and X-rays.  A
"detector" is modeled as a grid of pixels which detect particles and x-rays
impinging upon them.

General "detector" element attributes are:
\tt 
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset  
  Chamber Wall               \refs:wall      Reference energy           \refs:energy  
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods 
  Detector Geometry          \refs:surf.grid                                            
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "detector" element are:
  pixel         = {...}   ! Define detector pixel grid.

The detector pixels are are arranged in a rectangular grid. The general syntax for defining
a detector pixel grid is
  pixel = {
      ix_bounds = (<ix_min>, <ix_max>),  ! Min/max index bounds in x-direction
      iy_bounds = (<iy_min>, <iy_max>),  ! Min/max index bounds in y-direction
      r0 = (<x0>, <y0>),                 ! (x,y) coordinates at grid origin
      dr = (<dx>, <dy>)                  ! Spacing between grid points.
          }
See \Srefs:surf.grid for an explanation of the various pixel parameters.

Example:
  det: detector, pixels = 
          {ix_bounds = (-4,5), iy_bounds = (-10,10), dr = (0.01, 0.01)}
This example defines a detector with 1~cm x 1~cm pixels.

The "aperture_type"  parameter of a "detector" will default to "auto" which
will set the aperture limits to define a rectangular aperture that just cover the area of the pixel
grid.

A curved detector can be constructed by setting the appropriate surface curvature parameters
. It is assumed that any curvature is only in one dimension (x or y). This
allows a straight forward mapping of the rectangular pixel grid onto the curved surface.

###section Diffraction_Plate

A "diffraction_plate" element is a flat surface oriented, more or
less, transversely to a x-ray beam through which photon can travel. A
"diffraction_plate" can be used, for example, to model a Fresnel
zone plate or Young's double slits. A "diffraction_plate" element
is used in places where diffraction effects must be taken into
account. This is in contrast to setting an aperture attribute
 for other elements where diffraction effects are
ignored.

A "diffraction_plate" element is similar to a "mask"
 element except that with a "mask" element coherent
effects are ignored. Additionally, a "mask" element can be used
with charged particles while a "diffraction_plate" cannot.

General "diffraction_plate" element attributes are:
\tt 
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Offsets, pitches \& tilt   \refs:offset    
  Custom Attributes          \refs:cust.att Mask geometry              \refs:wall    
  Description strings        \refs:alias    Reference energy           \refs:energy  
  Is_on                      \refs:is.on    Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "diffraction_plate" element are:
  mode               = <Type>   ! Reflection or transmission
  field_scale_factor = <Real>   ! Factor to scale the photon field
  ref_wavelength                ! Reference wavelength . Dependent attribute .

The "mode" switch sets whether X-rays are transmitted through the
"diffraction_plate" or or reflected. Possible values for the
"mode" switch are:
  reflection
  transmission        ! Default

The geometry of the plate, that is, where the openings (in
transmission mode) or reflection regions are, is defined using the
"wall" attribute. See  for more details.

In transmission mode, a "diffraction_plate" is nominally orientated
transversely to the beam. Like all other elements, the
"diffraction_plate" can be reoriented using the element's offsets,
pitches and tilt attributes .

The "aperture_type"  parameter of a
"diffraction_plate" will default to "auto" which will set the
aperture limits to define a rectangular aperture that just cover the
clear area of the plate.

The "field_scale_factor", if set to a non-zero value (zero is the
default) will be used to scale the field of photons as they pass through
the "diffraction_plate" element:
  field -> field * field_scale_factor
Scaling is useful since the electric field of photons traveling through a
"diffraction_plate" are renormalized (see \Eqseeo4p and
\eqeek4p). This can lead to large variation of the photon field and
can, for example, make visual interpretation of plots of field verses
longitudinal position difficult to interpret. "field_scale_factor"
can be used to keep the field more or less constant.

A "diffraction_plate" that is "turned off" ("is_on" attribute
set to False), does not diffract at all and transmits through all
the light incident on it.

Example:
  fresnel: diffraction_plate, wall = {...}

###section Drift

A "drift" element is a space free and clear of any fields.

General "drift" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Offsets, pitches \& tilt   \refs:offset  
  Custom Attributes          \refs:cust.att Reference energy           \refs:energy   
  Description strings        \refs:alias    Symplectify                \refs:symp     
  Length                     \refs:l        Tracking \& transfer map   \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

Example:
  d21: drift, l = 4.5

Note: If a chamber wall  is needed for a field free
space, use a "pipe" element instead of a "drift" [a wall for a
drift is not allowed due to the way drifts are treated with
superposition. That is, drifts "disappear" when superimposed
upon. ].

###section E_Gun

An "e_gun" element represents an electron gun and encompasses a region starting from the cathode
were the electrons are generated.  General "e_gun" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section            
  Aperture limits            \refs:limit     Length                     \refs:l         
  Chamber wall               \refs:wall      Mag \& Elec multipoles     \refs:multip    
  Custom attributes          \refs:cust.att  Offsets, pitches \& tilt   \refs:offset     
  Description strings        \refs:alias     Overlapping Fields         \refs:overlap   
  Field autoscaling          \refs:autoscale Reference energy           \refs:energy     
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp      
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap  
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods    
  
\toffset
See for a full list of element attributes along with a their units.

The attributes specific to an "e_gun" are 
  gradient       = <Real>    ! Gradient.
  gradient_err   = <Real>    ! Gradient error.
  gradient_tot               ! Net gradient = gradient + gradient_err. Dependent param .
  phi0           = <Real>    ! Phase (rad/2\pi) of the reference particle with 
                             !   respect to the RF. phi0 = 0 is on crest.
  phi0_err       = <Real>    ! Phase error (rad/2\pi)
  rf_frequency   = <Real>    ! Frequency of the RF field.
  voltage        = <Real>    ! Voltage. Dependent attribute . 
  voltage_err    = <Real>    ! Voltage error. Dependent attribute . 
  voltage_tot                ! Net voltage = voltage + voltage_err. Dependent param .

The "voltage" is simply related to the "gradient" via the element length "l":
  voltage = gradient * l
If the "voltage" is set to a non-zero value, the length "l" must also be non-zero to keep the
gradient finite.  A particle with the charge as the reference particle will have a positive energy
gain if the "voltage" and "gradient" are positive and vice versa.

The "voltage" and "gradient" are scaled by "field_autoscale" and, if there is a
finite "rf_frequency", the phase of the frequency is shifted by "phi0_autoscale" as
discussed in Section~. Autoscaling can be toggled on/off by using the
"autoscale_phase" and "autoscale_amplitude" toggles.

An "e_gun" may either be DC if the "rf_frequency" component is zero of AC if
not. For an AC "e_gun", the phase of the "e_gun", The phase \phi_\REF
is 
  \phi_\REF = phi0 + phi0_err + phi0_autoscale 

Electrons generated at the cathode can have zero initial momentum and
this presents a special problem . As a result, the
use of "e_gun" elements are restricted and they can only be used in
a "linear" (non-recirculating) lattice branch. Only one "e_gun"
can be present in a lattice branch and, if it is present, it must be,
except for possibly "marker" or "null_ele" elements, the first
element in any branch.
 
Note: In order to be able to avoid problems with a zero reference momentum at the beginning of the
"e_gun", the reference momentum and energy associated with an "e_gun" element
 is calculated as outlined in Section~. Additionally, the
reference momentum at the exit end of the "e_gun", that is "p0c", must be non-zero. Thus, for
example, if "p0c" is zero at the start of the lattice, the "e_gun" voltage must be non-zero.

Additionally, in order to be able to avoid problems with a zero reference momentum at the
beginning of the "e_gun", absolute time tracking  is always used in
an "e_gun" element independent of the setting of "bmad_com[absolute_time_tracking]"
.

Note: The default "tracking_method"  setting for an
"e_gun" is "time_runge_kutta" and the default
"mat6_calc_method" is "tracking".

In this example the field of an e_gun is given by a grid of field
values :
  apex: e_gun, l = 0.23, field_calc = fieldmap, rf_frequency = 187e6, 
                grid_field = call::apex_gun_grid.bmad
with the file "apex_gun_grid.bmad" being:
  {
    m = 0, harmonic = 1,
    master_scale = voltage,
    geometry = rotationally_symmetric_rz,
    r0 = (0, 0),
    dr = (0.001, 0.001),
    pt(0,0) = ( (0, 0), (0, 0), (1, 0),  (0, 0), (0, 0), (0, 0)),
    pt(0,1) = ( (0, 0), (0, 0), (0.99, 0),  (0, 0), (0, 0), (0, 0)),
    ... }

###section ELseparator

An "elseparator" is an electrostatic separator.

General "elseparator" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section           
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip   
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset   
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap  
  Description strings        \refs:alias     Reference energy           \refs:energy    
  Fringe Fields              \refs:fringe    Superposition              \refc:super    
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp     
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods   
  Length                     \refs:l                                                     
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "elseparator" element are:
  gap = <Real> ! Distance between electrodes
  voltage      ! Voltage between electrodes. This is a settable dependent variable .
  e_field      ! Electric field. This is a settable dependent variable .

For an "elseparator", the kick for a positively charged particle, with the magnitude of
the charge that is the same as that of the reference particle (set by "parameter[particle]"
), is determined by "hkick" and "vkick". The kick for a negatively
charged particle is opposite this. The "gap" for an "Elseparator" is used to compute
the voltage for a given kick
  e_field (V/m) = sqrt(hkick^2 + vkick^2) * P0 * c_light / L
  voltage (V) = e_field * gap
Specifying a "e_field" or "voltage" with no tilt results in a vertical kick.

Examples:
  h_sep1: elsep, l = 4.5, hkick = 0.003, gap = 0.11
  h_sep2: elsep, l = 4.5, e_field = 1e5, tilt = pi/2

###section EM_Field

An "em_field" element can contain general electro-magnetic (EM)
fields. Both AC and DC fields are accommodated.  General "em_field"
attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Is_on                      \refs:is.on   
  Chamber wall               \refs:wall      Length                     \refs:l        
  Custom Attributes          \refs:cust.att  Offsets, pitches \& tilt   \refs:offset  
  Description strings        \refs:alias     Reference energy           \refs:energy  
  Field Maps                 \refs:fieldmap  Superposition              \refc:super   
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp    
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "em_field" element are:
  constant_ref_energy = <Logical> ! Is the reference energy constant? Default = True.
  polarity   = <Real>  ! For scaling the field.

The "polarity" value is used to scale the magnetic field. By
default, "polarity" has a value of 1.0.  Example:
  wig1: wiggler, l = 1.6, polarity = -1, cartesian_map = {...}

If the "constant_ref_energy" logical is set to "True" (the default), the reference energy
 at the exit end of the element is set equal to the entrance end reference
energy. This is the same behavior for most other elements. If the "constant_ref_energy" logical
is set to "False", the reference energy at the exit end is calculated like it is in a
"lcavity" or "e_gun" element.

Note: "em_field" elements will be created when elements are superimposed  and
there is no other suitable element class.

###section Feedback

A "feedback" element is a lord element with two types of slaves called the "input" slaves and
"output" slaves.  The feedback element gathers information about particle trajectories from the
input slaves and uses this to either adjust beam trajectories in the output slaves and/or adjust
parameters in the output slaves. A feedback element could be used, for example, to simulate RF feedback
systems or beam position feedback, or cooling of a proton beam by a beam of electrons.

General "feedback" element attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Description strings        \refs:alias     
  
\toffset
See for a full list of element attributes along with a their units.

NOTE! 2024/3 The "feedback" element is currently under development so changes can be expected in the future.

Attributes specific to a "feedback" element are:
  input_ele  = <list>   ! Lattice element(s) feedback element gets information from
  output_ele = <list>   ! Lattice elements(s) where the feedback element can influence
                        !   particle trajectories or element parameters.

The "input_ele" parameter defines a list of lattice elements that specify, when tracking particles,
where the "feedback" element will monitor particle trajectories. The "output_ele" parameter
defines a list of lattice elements that specify the points at which the "feedback" element can
either modify particle trajectories and/or modify lattice element parameters.

The "<list>" of lattice elements uses the standard Bmad name matching conventions as given in
. If commas are used in the "<list>", the list must be enclosed in curly
backets "{...\" to avoid ambiguities. Curly brackets are optional when commas are not
used. Examples:
  fff: feedback, input_ele = bpm5, 
                  output_ele = kicker3      ! Single input and output elements.
  fe2: feedback, input_ele = {bpm5}, 
                  output_ele = rfcavity::*  ! Output to all RF cavities.
  g7: feedback, input_ele = {mon1, mon2}, 
                  output_ele = type::IRQ    ! Match to element's type field.

The set of "input_ele" and "output_ele" elements will be "minor_slave" slaves of the
"control_lord" "feedback" element. Like other lord elements ("group"s, "overlay"s,
etc.), particles are never tracked through a "feedback" element itself.

Since feedback systems vary greatly in how they work, a generic feedback element is not currently
planned (but could be in the future as more experience is gained developing feedback simulation
code).  This being the case, a program must be specifically setup to handle feedback elements. In
particular, feedback elements in a lattice will not affect any calculation when using the "Tao"
program (but "Tao" can still be used to inspect feedback elements and their slaves).

Currently, the only program that handles "feedback" elements is the "e_cooling" program that
is located in the "bsim" directory of a "Bmad" Release (and this program is currently under
development and not ready for doing simulations). A feedback aware program will handle the task
of feedback related parameter setup so the program documentation should be consulted for specifics.

###section Fiducial

A "fiducial" element is used to fix the position and orientation of the reference orbit within
the global coordinate system at the location of the "fiducial" element. A "fiducial" element
will affect the global floor coordinates  of elements both upstream and downstream
of the fiducial element.

Other elements that are used to shift the lattice in the global coordinate frame are
"floor_shift"  and "patch" .

General "fiducial" element attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Reference energy           \refs:energy  
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "fiducial" elements are:
  origin_ele        = <Name>     ! Reference element.
  origin_ele_ref_pt = <location> ! Reference pt on reference ele.
  dx_origin         = <Real>     ! x-position offset
  dy_origin         = <Real>     ! y-position offset
  dz_origin         = <Real>     ! z-position offset
  dtheta_origin     = <Real>     ! orientation angle offset.
  dphi_origin       = <Real>     ! orientation angle offset.
  dpsi_origin       = <Real>     ! orientation angle offset.

For tracking purposes, the "fiducial" element is considered to be a
zero length marker. That is, the transfer map through a "fiducial"
element is the unit map.

A "fiducial" element sets the global floor coordinates  of itself and of the
elements, both upstream and downstream, around it. This can be thought of as a two step process. The
first step is to determine the global coordinates of the "fiducial" element itself, and the
second step is to shift the coordinates of the elements around it. That is, shifting the position
of a "fiducial" element shifts the lattice elements around it as one solid body.

The floor coordinates of the "fiducial" element are determined starting with an "origin_ele"
element. If "origin_ele" is not specified, the origin of the global coordinates (
is used. If the "origin_ele" has a finite length, the reference point may be chosen using the
"origin_ele_ref_pt" attribute which may be set to one of
  entrance_end
  center         ! Default
  exit_end

Once the origin reference position is determined, the reference
position of the "fiducial" element is calculated using the offset
attributes 
  [dx_origin,  dy_origin,  dz_origin]
  [dtheta_origin,  dphi_origin,  dpsi_origin]
The transformation between origin and fiducial positions is given in
.

Once the position of the "fiducial" element is calculated, all elements of the lattice branch the
"fiducial" element is contained in, \em both the upstream and downstream elements, are shifted
so that everything is consistent. That is, the "fiducial" element orients the entire lattice
branch. The exception here is that if there are "flexible" "patch" elements 
in the lattice branch, the "fiducial" element will only determine the positions up to the
"flexible" "patch" element.

Example: A lattice branch with elements 0 through 103 has a "fiducial" element at position 34 and
a "flexible" "patch" at position 67. In this case the "fiducial" element will determine the
reference orbit for elements 0 through 66.

Rules: 
  *
If an "origin_ele" is specified, the position of this element must to calculated before the
position of the "fiducial" element is calculated . This means, the "origin_ele"
must be in a prior lattice branch from the branch the "fiducial" element is in or the
"origin_ele" in the same branch as the "fiducial" element but is positioned upstream from the
"fiducial" element and there is a "flexible" "patch" in between the two elements.
  *
If a "fiducial" element affects the position of element 0 in the lattice branch (that is, there
are no flexible "patch" elements in between), any positioning of element 0 via "beginning" or
"line parameter" statements  are ignored.
  *
"Fiducial" elements must not over constrain the lattice geometry.  For example, two "fiducial"
elements may not appear in the same lattice branch unless separated by a "flexible" "patch".

Another example is that if there are no flexible "patch" elements in the lattice, and if branch
"A" has a "branch" element connecting to branch "B", the geometry of branch "A" will be
calculated first and the geometry of branch "B" can then be calculated from the known coordinates
of the "fork" element. If branch "B" contains a "fiducial" element then this is an error
since the coordinate calculation never backtracks to recalculate the coordinates of the elements of
a branch once the calculation has finished with that branch.

Example:
  f1: fiducial, origin_ele = mark1, x_offset = 0.04
See for an example where a fiducial element is
used to position the second ring in a dual ring colliding beam 
machine.

###section Floor_Shift

A "floor_shift" element shifts the reference orbit in the global coordinate system without
affecting particle tracking. That is, in terms of tracking, a "floor_shift" element is equivalent
to a "marker"  element. 

Also see "patch"  and "fiducial"  elements.

General "floor_shift" element attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Reference energy           \refs:energy  
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods 
  Length                     \refs:l                                                    
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "floor_shift" elements are:
  l                 = <Real>     ! Length
  x_offset          = <Real>     ! x offset from origin point.
  y_offset          = <Real>     ! y offset from origin point.
  z_offset          = <Real>     ! z offset from origin point.
  x_pitch           = <Real>     ! rotation of the reference coords.
  y_pitch           = <Real>     ! rotation of the reference coords.
  tilt              = <Real>     ! rotation of the reference coords.
  origin_ele        = <Name>     ! Reference element.
  origin_ele_ref_pt = <location> ! Reference pt on the reference ele.

The "floor_shift" element sets the reference orbit at the exit end of the "floor_shift"
element as follows: Start with the reference orbit at the "origin_ele" reference point (see
below). This coordinate system is shifted using the offset, pitch and tilt parameters of the
"floor_shift" element. The shifted coordinate system is used as the coordinate system at the exit
end of the "floor_shift" element. The reference position transformation through a
"floor_shift" element is given in Section~. In this respect, the "floor_shift"
element is similar to the "fiducial" element. The difference being that the "fiducial" element affects
the global floor coordinates of elements both upstream and downstream of the "fiducial" element while a
"floor_shift" element only affects the floor position of elements downstream from it.
 
Like a "fiducial" element, the transfer map through a "floor_shift" element will be the
unit map. That is, the phase space coordinates of a particle will not change when tracking through a
"floor_shift" element. 

The "l" attribute can be used to adjust the longitudinal s position.

The "floor_shift" element can be used, for example, to restore the
correct global geometry when a section of the lattice is represented by, say,
a "taylor" type element.

If an "origin_ele" is not specified, the default "origin_ele" is the lattice element before
the "floor_shift" element.  If an "origin_ele" is specified, Bmad needs to be able to
calculate the position of this element before the position of the "fiducial" element is
calculated. See the discussion of the "origin_ele" for "fiducial" elements
.  Notice that if the "origin_ele" is specified, and is different from the
element upstream from the "floor_shift" element, the coordinates at the exit end of the
"floor_shift" element is independent of the coordinates of the upstream element.

If the "origin_ele" has a finite length, the reference point may be chosen using the
"origin_ele_ref_pt" attribute which may be set to one of
  entrance_end
  center
  exit_end         ! Default

PTC does not have an analogous element for the "Floor_shift" element. When converting to PTC, a
"floor_shift" element will be treated as a "marker" element.

Example: 
  floor: floor_shift, z_offset = 3.2
This offsets the element after the "floor_shift" 3.2 meters from the previous
element.

###section Foil

  \includegraphics[width=5in]foil.pdf
Foil geometry. Parameters "thickness", "dthickness_dx", "x1_edge", "x2_edge",
"y1_edge", and "y2_edge" determine the foil geometry in body coordinates (see \figf:coords).
For the drawing, "x1_edge" is negative (the associated edge is to the left of x = 0) and the
"x2_edge" is positive.  Orientation parameters like "x_offset"  orient the
foil with respect to laboratory coordinates but do not change the foil shape.

A "foil" element represents a planar sheet of material which can strip electrons from a particle.
In conjunction, there will be scattering of the particle trajectory as well as an associated energy
loss.

General "foil" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy      
  Description strings        \refs:alias     Superposition              \refc:super      
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods     
  Is_on                      \refs:is.on                                                   
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "foil" element are:
  material_type       = <String>  ! Foil material.
  thickness           = <Real>    ! Material thickness (m).
  density             = <Real>    ! Input material density (kg/m^3).
  density_used                    ! Density value used in tracking (kg/m^3).
  radiation_length    = <Vector>  ! Input material radiation length (m).
  radiation_length_used           ! Radiation length used in tracking (m).
  area_density        = <Vector>  ! Input material area density (kg/m^2).
  area_density_used               ! Area density used in tracking (kg/m^2).
  F_factor            = <Real>    ! lynch_dahl scattering F factor. Default: 0.98.
  final_charge        = <Integer> ! Final charge state
  scatter_test        = <Logic>   ! For testing scattering. Default: False.
  scatter_method      = <Switch>  ! Scattering algorithm. Default: highland.
  dthickness_dx       = <Real>    ! Wedge slope when the foil is wedge shaped.
  x1_edge             = <Real>    ! Foil edge in the x-direction. Default: -99 m.
  x2_edge             = <Real>    ! Foil edge in the x-direction. Default:  99 m.
  y1_edge             = <Real>    ! Foil edge in the y-direction. Default: -99 m.
  y2_edge             = <Real>    ! Foil edge in the y-direction. Default:  99 m.

Scattering is simulated to be Gaussian distributed with a sigma calculated in one of two methods.
The two scattering algorithms are given in section~. Which algorithm is used is
determined by the "scatter_method" parameter which can be set to:
  highland        ! Default
  lynch_dahl
  off             ! No scattering

Additionally, the "scatter_test" logical may be used for testing. If set to True (default is
False), the random numbers used in \Eqdpr1s are set to 1.

Energy loss is calculated using the Bethe-Bloch formula as discussed in section~.

The "material_type" is the type of material which can be elemental or a compound material.

The radiation length used in the scattering calculation is given by the "radiation_length_used"
parameter. For compound materials, this parameter is a vector with each value of the vector being the
radiation length of the corresponding component.  "Radiation_length_used" cannot be set
directly. Rather, if the "radiation_length" parameter is set non-zero, the value (or values for
a compound material) will be transferred to "radiation_length_used". If "radiation_length" is
zero (the default), the value of "radiation_length_used" will be set by Bmad using measured
values from the published literature.

Similarly, the "area_density_used" (density of the material per unit of surface area) value (or
values for a compound material) needed for the calculation is not set directly but is set in one of
two ways depending upon if the material "thickness" is non-zero or not. If "thickness" is
non-zero, "area_density_used" is set by the product of "thickness" and "density_used" while
the value of "density_used" is set by Bmad to be either the value "density" if the
"density" is non-zero or by the measured density of the material as given in the published
literature. If "thickness" is zero (the default), the value of "area_density_used" is set
equal to the value of "area_density". Note that the value of "density_used" is only used to
set "area_density_used" when "thickness" is non-zero and otherwise does not affect the
tracking calculation.

Example:
  f1: foil, thickness = 1e-2, material_type = "B4C", 
          density = (2e3, 1e3), radiation_length = (5.49, 4.26)
  f1: foil, thickness = 1e-2, material_type = "B4C", 
          density = 9e3, radiation_length = (5.49, 4.26)  ! Same as above
Here, since "material_type" is set to "B4C", there are two components: Boron and Carbon. If
"radiation_length" is used, it must have the same number of values as the number of material
components. If "density", or "area_density" is used they either must have the same number of
values as the number of material components or they can have a single value.  If there is a single
value, this value represents the sum of the individual component values.

Values are set in order so, in the above example, the
Carbon component has a density of 1e3 and a radiation length of 4.26.\footnote
  
From a computational standpoint it does not matter which parameter is associated with which component.
  
In the case where there is a component material, either "density" or "area_density" needs to
be set since Bmad is not able to calculate appropriate values in this case. When there is only one
component, the parentheses may be omitted. Example:
Example:
  stripper: foil, material_type = "Cu", thickness = 0.127, &
                                  radiation_length = 12.3, x1_edge = -0.3

In terms of element placement, The length of a "foil" element (\Eql00l) is considered to be
zero.  This is similar to the "beambeam" element which is also considered to have zero length but
the interaction occurs over a finite length.

The 6x6 transfer matrix of a "foil" element is the unit matrix. That is, scattering does
not affect the transfer matrix.

Particles going through the "foil" are stripped to have a final charge given by
"final_charge".  The default is to fully strip the particle except if the particle has no
electrons to strip, there will be no change in charge state.

The foil has a rectangular shape and particles will only be considered to have hit the foil if:
  x1_edge < x_particle < x2_edge  and
  y1_edge < y_particle < y2_edge
where (x_particle, y_particle) are the coordinates of the particle in the element body (not the
laboratory) coordinate system (\figf:coords). See \figf:foil. Particles that do not hit the
foil pass through the element without a change in charge nor a change in trajectory. The default
for "x1_edge" and "y1_edge" is -99~meters and for "x2_edge" and "y2_edge" the default is
+99~meters.

The "dthickness_dx" parameter can be used to get a varying foil thickness. The thickness t at
a point (in body coordinates) (x,y) on the foil will be
  t = t_0 + x \, \fracdtdx
where t_0 is the thickness given by the "thickness" parameter and dt/dx is given by the
"dthickness_dx" parameter. To orient the wedge in the transverse plane, use the "tilt"
orientation parameter . If "dthickness_dx" is non-zero, the
"area_density" and "thickness" parameters are defined to be the area density and thickness at
(x,y) = (0,0). If "dthickness_dx" is non-zero, and if "area_density" is
set (as opposed to setting the "density"), then the "thickness" must be non-zero since otherwise
the calculation of the area density at the point where a particle passes through the foil is singular.

If a "foil" element is part of a lattice branch with a closed geometry, the closed orbit
calculation will tempararily set the "scatter" parameter to false since scattering is a random
process and the closed orbit is not well defined in the presence of any random processes (similarly,
radiation fluctuations are also turned off for the closed orbit calculation).

###section Fork and Photon_Fork

  \includegraphics[width=5in]x-fork.pdf
  
Example use of "photon_fork" elements showing four X-ray lines (branches) attached to a machine.
  
A "fork" or "photon_fork" element marks the start of an alternative "branch" for the beam
(or X-rays or other particles generated by the beam) to follow.

Collectively "fork" and "photon_fork" elements are called forking elements. An example
geometry is shown in \figf:x.fork.  The "branch" containing a forking element is called the
""base" "branch"". The "branch" that the forking element points to is called the
""forked-to" "branch"".

The only difference between "fork" and "photon_fork" is that the default particle type for the
forked-to branch forked from a "fork" element is the same particle type as the base branch. The
default particle type for the forked-to branch from a "photon_fork" element is a photon. The actual
particle associated with a branch can be set by setting the "particle" attribute of the forking
element.

General "fork" and "photon_fork" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Length                     \refs:l       
  Chamber wall               \refs:wall      Reference energy           \refs:energy   
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods  
  Is_on                      \refs:is.on                                                
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to "fork" and "photon_fork" elements are:
  direction    = <+/- 1>      ! Particles are entering or leaving?
  to_line      = <LineName>   ! What line to fork to.
  to_element   = <ElementID>  ! What element to attach to in the line being forked to.
  new_branch   = <T/F>        ! Make a new branch from the to_line? Default = True.

Branch lines can themselves have forking elements. A branch line always starts out tangential to the
line it is branching from.  A "patch" element  can be used to reorient the
reference orbit as needed. Example:
  from_line: line = (... A, PB, B, ...)  ! Defines base branch
  pb: photon_fork, to_line = x_line
  x_line: line = (X_PATCH, X1, X2, ...)     ! Defines forked-to branch
  x_line[p0c] = 1e3                         ! Photon reference momentum   
  x_patch: patch, x_offset = 0.01
  use, from_line
In this example, a photon generated at the fork element "PB" with x = 0 with respect to the
"from_line" reference orbit through "PB" will, when transferred to the "x_line", and
propagated through "X_PATCH", have an initial value for x of -0.01.

Forking elements have zero length and, like "marker" elements, the position of a particle tracked
through a forking element does not change.

Forking elements do not have orientational attributes like "x_pitch" and "tilt"
(\refs:offset). If the orientation of the forked-to branch needs to be modified, this can be
accomplished using a "patch" element at the beginning of the line.

The "is_on" attribute, while provided for use by a program, is ignored by Bmad proper.

If the reference orbit needs to be shifted when forking from one ring to another ring, a patch can
be placed in a separate "transfer" line to isolate it from the branches defining the
rings. Example:
  ring1: line = (... A, F1, B, ...)     ! First ring
  x_line: line = (X_F1, X_PATCH, X_F2)  ! "Transfer" line
  ring2: line = (... C, F2, D, ...)     ! Second ring
  use, ring1

  f1: fork, to_line = x_line
  f2: fork, to_line = x_line, direction = -1
  x_patch: patch, x_offset = ...
  x_f1: fork, to_line = ring1, to_element = f1, direction = -1
  x_f2: fork, to_line = ring2, to_element = f2
Here the "fork" "F1" in "ring1" forks to "x_line" which
in turn forks to "ring2".

The above example also illustrates how to connect machines for particles going in the reverse
direction. In this case, rather than using a single "fork" element to connect lines, pairs of
"fork" elements are used. "Ring2" has a "fork" element "f2" that points back through
"x_line" and then to "ring1" via the "x_f1" fork. Notice that both "f2" and "x_f2"
have their "direction" attribute set to -1 to indicate that the fork is appropriate for particles
propagating in the -s direction. Additionally, since "f2" has "direction" set to -1, it
will, by default, connect to the downstream end of the "x_line". The default setting of
"direction" is 1.

It is important to note that the setting of "direction" does not change the placement of elements
in the forked line. That is, the global position  of any element is unaffected by
the setting of "direction". To shift the global position of a forked line, "patch"
elements must be used. In fact, the "direction" parameter is merely an indicator to a program on
how to treat particle propagation. The "direction" parameter is not used in any calculation done
by Bmad.

The "to_element" attribute for a forking element is used to designate the element of the forked-to
branch that the forking element connects to. To keep things conceptually simple, the "to_element"
must be a "marker-like" element which has zero length and unit transfer matrix. Possible
"to_element" types are:
  beginning_ele
  fiducial
  fork and photon_fork
  marker
When the "to_element" is not specified, the default is to connect to the beginning of the forked-to
branch if "direction" is 1 and to connect to the end of the downstream branch if "direction" is
-1. In this case, there is never a problem connecting to the beginning of the forked-to branch since
all branches have a "beginning_ele" element at the beginning. When connecting to the end of the
forked-to branch the last element in the forked-to branch must be a marker-like element. Note that, by
default, a marker element is placed at the end of all branches 

The default reference particle type of a branch line will be a "photon" is using a
"photon_fork" or will be the same type of particle as the base branch if a "fork" element is
used. If the reference particle of a branch line is different from the reference particle in the
base branch, the reference energy (or reference momentum) of a forked-to branch line needs to be set
using line parameter statements . If the reference particle of a branch line is
the same as the reference particle in the base branch, the reference energy will default to the
reference energy of the base branch if the reference energy is not set for the branch.

Example showing an injection line branching to a ring which, in turn, branches to two x-ray lines:
  inj: line = (..., br_ele, ...)            ! Define the injection line
  use, inj                                  ! Injection line is the root
  br_ele: fork, to_line = ring              ! Fork element to ring
  ring: line = (..., x_br, ..., x_br, ...)  ! Define the ring
  ring[E_tot] = 1.7e9                       ! Ring ref energy.
  x_br: photon_fork, to_line = x_line       ! Fork element to x-ray line
  x_line: line = (...)                      ! Define the x-ray line
  x_line[E_tot] = 1e3

The "new_branch" attribute is, by default, "True" which means that the lattice branch created
out of the "to_line" line is distinct from other lattice branches of the same name. Thus, in the
above example, the two lattice branches made from the "x_line" will be distinct. If
"new_branch" is set to "False", a new lattice branch will not be created if a lattice branch
created from the same line already exists. This is useful, for example, when a chicane line branches
off from the main line and then branches back to it.

When a lattice is expanded , the branches defined by the "use" statement
 are searched for fork elements that branch to new forked-to branches. If found, the
appropriate branches are instantiated and the process repeated until there are no more branches to
be instantiated. This process does \em not go in reverse. That is, the lines defined in a lattice
file are not searched for fork elements that have forked-to instantiated branches. For example, if, in
the above example, the use statement was:
  use, x_line
then only the "x_line" would be instantiated and the lines "inj" and "ring" would be
ignored.

If the forked-to branch and base branch both have the same reference particle, and if the element
forked into is the beginning element, the reference energy and momentum of the forked-to branch will be
set to the reference energy and momentum at the fork element. In this case, neither the reference
energy nor reference momentum of the forked-to branch should be set. If it is desired to have the
reference energy/momentum of the forked-to branch different from what is inherited from the fork
element, a patch element  can be used at the beginning of the forked-to branch. In all
other cases, where either the two branches have different reference particles or the fork connects
to something other than the beginning element, there is no energy/momentum inheritance and either
the reference energy or reference momentum of the forked-to branch must be set.

How to analyze a lattice with multiple branches can be somewhat complex and will vary from program
to program. For example, some programs will simply ignore everything except the root branch. Hopefully
any program documentation will clarify the matter.

###section Girder

  \includegraphicsgirder.pdf
Girder supporting three elements labeled "A", "B", and "C".  \calO_A is the reference
frame at the upstream end of element "A" , \calO_C is the reference
frame at the downstream end of element "C", and \calO_G is the default "origin" reference
frame of the girder if the "origin_ele" parameter is not set. r_CA is the vector from
\calO_A to \calO_C. The length "l" of the girder is set to be the difference in s between
points \calO_C and \calO_A.
  
A "girder" is a support structure that orients the elements that are attached to it in space. A
girder can be used to simulate any rigid support structure and there are no restrictions on how the
lattice elements that are supported are oriented with respect to one another.  Thus, for example,
optical tables can be simulated.

General "girder" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Length                     \refs:l       
  Description strings        \refs:alias     Offsets, pitches \& tilt   \refs:offset   
  Is_on                      \refs:is.on                                                
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "girder" are:
Attributes specific to "girder" elements are:
  girder = {<List>}   ! List of elements on the Girder
  origin_ele        = <Name>     ! Reference element.
  origin_ele_ref_pt = <location> ! Reference pt on reference ele.
  dx_origin         = <Real>     ! x-position offset
  dy_origin         = <Real>     ! y-position offset
  dz_origin         = <Real>     ! z-position offset
  dtheta_origin     = <Real>     ! orientation angle offset.
  dphi_origin       = <Real>     ! orientation angle offset.
  dpsi_origin       = <Real>     ! orientation angle offset.
  l                 ! Girder "Length" (\refs:l). Dependent attribute .

A simple example of a girder is shown in \figf:girder. Here a girder supports three
elements labeled "A", "B", and "C" where "B" is a bend so the geometry is
nonlinear. Such a girder may specified in the lattice file like:
  g1: girder = {A, B, C}

The "girder" statement can take one of two forms:
  <element_name>: GIRDER = {<ele1>, <ele2>, ..., <eleN>}, ... 
or
  <element_name>: GIRDER = {<ele_start>:<ele_end>}, ... 

With the first form, a "girder" element will be created for each section of the lattice where
there is a "consecutive" sequence of "slave" elements "<ele1>" through "<eleN>".  This
section of the lattice from "<ele1>" through "<eleN>" is called the "girder support region".
"Consecutive" here means there are no other elements in the girder support region except for
possibly "drift" and/or "marker" elements. "Drift" elements cannot be controlled by a
girder\footnoteThis policy was created to avoid the problem where the superposition of marker
elements on top of drifts would prevent girder formation. but may appear in the girder slave
list. If a "drift" does appear in the slave list, "drift" elements will not be ignored when
determining if elements are consecutive. Note: If a drift-like element is desired to be supported by
a "girder", use a "pipe" element instead. "Marker" elements present in a girder support
region, but not mentioned in the girder slave list, are simply ignored.

The second form of a "girder" statement specifies the first and last elements in the sequence of
elements to be supported. Everything in between except "drift" elements will be supported by the
"girder".

Wild card characters  can be used in any element name in the girder slave
list. Additionally, beam line names  can be used. In this case, any
"drift" elements within a beam line will be ignored.

A lattice element may have at most one "girder" supporting it. However, a "girder" can be
supported by another "girder" which in turn can be supported by a third "girder", etc. Girders
that support other girders must be defined in the lattice file after the supported girders are
defined. Example:
  g1: girder = {A, B, C}
  g2: girder = {g1}      ! g2 must come after g1 

A "girder" may not directly support "multipass_slave"  or "super_slave"
 elements. Rather, a "girder" may support the corresponding lord elements.

The reference frame from which the girder's offset, pitch, and tilt attributes  are
measured is constructed as follows: A reference frame, called the ""origin"" reference frame
may be defined using the attributes "origin_ele" and "origin_ele_ref_pt" which constructs the
girder's "origin" frame to be coincident with the reference frame of another element. Example:
  g2: girder = {...}, origin_ele = Q, origin_ele_ref_pt = entrance_end
In this example, girder "g2" has an "origin" reference frame coincident with the entrance end
frame of an element named "Q". Valid values for "origin_ele_ref_pt" are
  entrance_end
  center        ! Default
  exit_end
For "crystal", "mirror", and "multilayer_mirror" elements, setting "origin_ele_ref_pt"
to "center" results in the reference frame being the frame of the surface (cf.~\figf:surface).

To specify that the global coordinates  are to be used for a girder set
"origin_ele" to
  global_coordinates
Typically this is the same as using the "beginning"
element  as the "origin_ele" except when the "beginning" element is offset
or reoriented .

If "origin_ele" is not given, the default "origin" frame is used. The default "origin"
frame is constructed as follows: Let \calO_A be the reference frame of the upstream end of the
first element in the list of supported elements. In this example it is the upstream end of element
"A" as shown in the figure. Let \calO_C be the downstream end of the last element in the list
of supported elements. In this example this is the downstream end of element "C". The origin of
the "girder"'s reference frame, marked \calO_G in the figure, will be half way along the vector
r_CA from the origin of \calO_A to the origin of \calO_B. The orientation of \calO_G is
constructed by rotating the \calO_A coordinates about an axis perpendicular to the z-axis of
\calO_A and r_CA such that the z-axis of \calO_G is parallel with r_CA.

Once the "origin" reference frame is established, the reference frame of the girder can be offset
from the "origin" frame using the parameters
  dx_origin    dtheta_origin
  dy_origin    dphi_origin
  dz_origin    dpsi_origin
The orientation of the "girder"'s reference frame from the "origin"
frame is given in. Example:
  g3: girder = { ... }, dx_origin = 0.03
This offsets girder "g3"'s reference frame 3~cm horizontally from
the default "origin" frame. If no offsets are given, the
"origin" frame is the same as the girder's reference frame.

The length "l" of a girder, which is not used in any calculations,
is a dependent attribute computed by Bmad and set equal to the s
path length between points \calO_C and \calO_A.

The physical orientation of the girder with respect to it's reference
frame is, like other elements, determined by the offset, pitch and
tilt orientation attributes as outlined in and
.  When a girder is shifted in space, the elements
it supports are also shifted.  In this case, the orientation
attributes ("x_offset", "y_pitch", etc.) give the orientation of
the element with respect to the "girder". The orientation with
respect to the local reference coordinates is given by
"x_offset_tot", which are computed from the orientation attributes
of the element and the "girder". An example will make this clear:
  q1: quad, l = 2
  q2: quad, l = 4, x_offset = 0.02, x_pitch = 0.01
  d: drift, l = 8
  g4: girder = {q1, q2}, x_pitch = 0.002, x_offset = 0.03
  this_line: line = (q1, d, q2)
  use, this_line
In this example, "g4" supports quadrupoles "q1" and "q2".
Since the supported elements are colinear, the computation is greatly
simplified. The reference frame of "g4", which is the default
"origin" frame, is at s = 7~meters which is half way between the
start of "q1" at at s = 0~meters and the end of "q2") which is
at s = 14. The reference frames of "q1" and "q2" are at their
centers so the s positions of the reference frames is
  Element        S_ref   dS_from_g4
  q1             1.0     -6.0
  g4             7.0      0.0
  q2            12.0      5.0
Using a small angle approximation to simplify the calculation, the "x_pitch" of "g4" produces
an offset at the center of "q2" of 0.01 = 0.002 * 5. This, added to the offsets of "g4" and
"q2", give the total "x_offset", denoted "x_offset_tot" of "q2" is 0.06 = 0.01 + 0.03 +
0.02. The total "x_pitch", denoted "x_pitch_tot", of "q2" is 0.022 = 0.02 + 0.001.

A "girder" that has its "is_on" attribute set to False is considered to be unsifted with
respect to it's reference frame.

###section GKicker

A "gkicker" element is a "general" zero length kicker element that can displace
a particle in all six phase space dimensions.

General "group" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Description strings        \refs:alias    
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "gkicker" are:
  x_kick        = <Real>  ! X-position kick
  px_kick       = <Real>  ! X-momentum kick
  y_kick        = <Real>  ! Y-position kick
  py_kick       = <Real>  ! Y-momentum kick
  z_kick        = <Real>  ! Z-position kick
  pz_kick       = <Real>  ! Momentum kick

Example:
  gk: gkicker, x_kick = 0.003, pz_kick = 0.12

###section Group

"Group" elements are a type of "control" element  used to make variations
in the attributes of other elements (called "slave" attributes) during execution of a program. For
example, to simulate the action of a control room knob that changes the beam tune in a storage ring,
a "group" element can be used to vary the strength of selected quads in a specified manner. Also
see "overlay"  The difference between "group" and "overlay" elements is
that "overlay" elements set the values of the attributes directly while "group" elements make
delta changes to attribute values.

General "group" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Is_on                      \refs:is.on    
  Description strings        \refs:alias                                                 
  
\toffset
See for a full list of element attributes along with a their units.

There are two types of "group" elements: "Expression" based and "knot" based.
The general syntax for a "expression" based "group" element is
  name: GROUP = {ele1[attrib1]:exp1, ele2[attrib2]:exp2, ...}, 
              VAR = {var1, var2, ...}, var1 = init_val1, old_var1 = init_val_old1, ...
where "ele1"["attrib1"], "ele2"["attrib2"], etc. specify the slave attributes and
"exp1", "exp2", etc. are the arithmetical expressions, that are functions of "var1",
"var2", etc., and are used to determine a value for the slave attributes.

The general syntax for a "knot" based  "group" element is
  name: GROUP = {ele1[attrib1]:{y_knot_points1}, ele2[attrib2]:{y_knot_points2}, ...}, 
              VAR = {var1}, X_KNOT = {x_knot_points}, INTERPOLATION = {type}, 
              var1 = init_val1, old_var1 = init_val_old1, ...
When using knot points, the "group" may only have one variable parameter.

\textbfSee Section~ for a detailed description of this syntax.

Example of a "expression" based "group" element:
  gr1: group = {q[k1]:a+b^2}, var = {a, b}, a = 1, old_a = 2
  gr1[old_b] = 2
There are two numbers associated with each variable in a group: One number is the value of the
variable (also called the "present" value) and the other number is the "old" value. To refer to
these old values prepend the string "old_" to the variable name. Thus, in the above example, the
old variable values have names "old_a" and "old_b" and these old values can be set in the same
manner as the present values.

Example of a "knot" based "group" element:
  gr2: group = {beginning[E_tot]]:{4e6,...}}, 
      var = {time}, x_knot = {...}, interpolate = cubic
Here the function used to translate from the "group"'s variables to the slave attribute values is
a cubic spline interpolation based upon the knot points specified .

A "group" element is like an "overlay" element in that a "group" element controls the
attribute values of other "slave" elements. The difference is that the value of a slave attribute
that is controlled by (one or more) "overlay" elements is uniquely determined by the controlling
"overlay" elements. A "group" element, on the other hand, is used to make changes in
value. An example will make this clear:
  gr: group = {q1[k1]:0.1*a^2}, var = {a}, a = 2, old_a = 1
  q, quad, k1 = 0.5
When a program reads the lattice file, initially the value of "q[k1]" will be 0.5 as set
in the definition of "q". Later, during lattice expansion , the group elements
are added to the lattice. When the group element "gr" is added, the fact that "old_a" and
"a" are different causes the value of "q[k1]" to be modified. The delta value is
  delta = 0.1*a^2 - 0.1*old_a^2
        = 0.3
And this is added to the existing value of 0.5 so that the value of "q[k1]" becomes 0.8.  After
the value of "q[k1]" has been updated, the value of "old_a" is automatically update to be the
present value of "a" so that the value of "q[k1]" will not be further modified.

In general, deltas used to modify slave attributes are computed as the difference between the
arithmetic expression evaluated with the present variable values and the arithmetic expression
evaluated with the old variable values.

Notice that in a lattice file the value of a slave attribute after the lattice is read in is
independent of whether the group is defined before or after elements whose attributes are controlled
by the group. This is true since the effect of a "group" element happens when the lattice is
expanded, not when parser reads the "group" definition. On the other hand, after the lattice has
been read in, if a program varies both a group variable and a slave attribute, the value of the
slave attribute will be dependent upon the order of which is modified first. For example, consider a
lattice containing:
  gr: group = {q[k1]:a^2}, var = {a} 
  q, quad
Now if a program first sets "gr[a]" to 0.3 and then sets "q[k1]" to 0.5, the result is that
"q[k1]" will have a value of 0.5. That is, the value of "q[k1]" will be independent of
"gr[a]". If the setting is reversed so that "q[k1]" is set first, the value of "q[k1]" will
be 0.59. Since the result is order dependent, trying to "simultaneously" vary the attributes of
both group variables and slave attributes can lead to unpredictable results. For example, consider
lattice "optimization" where a program varies a set of lattice parameters to achieve certain goals
(for example, minimum beta at some point in the lattice, etc.). If the list of parameters to be
varied contains both group variables and slave attributes, the actual changes to slave attributes
may be different from what the user expects when the program varies its list of parameters.

During running of a program, If a "group" element has been turned off ("is_on" parameter set
false), a change to a variable of the group element is saved but the old variable value is not
updated and slave parameters are not affected. Subsequently, turning on the group element will
result in the appropriate changes to the slave parameters and the old variable value.

Different "group" elements may control the same slave attribute and a "group" element may
control other "group", "overlay" or "girder" element attributes. However, It does not make
sense, and it is not permitted, for a "group" element to control the same attribute as an
"overlay" element or for a "group" element to control a "dependent" attribute
. To setup a group element to control the same slave attribute as an "overlay",
define an intermediate "overlay". For example:
  ov: overlay = {qk1\, q2[k1], ...}, var = {a}
  q, quad                                          
  gr: group = {ov_q[k1]:a^2}, var = {a}  ! New
  ov_q: overlay = {q}, var = {k1}        ! New
In this example, the overlay "ov" controls the attribute "q[k1]" so it is not permitted for
"q[k1]" to be a slave of a group element.  To have group control of "q[k1]", two elements are
introduced: the group "gr" is setup controlling "ov_q[k1]" and overlay "ov_q" is an overlay
that controls "q[k1]". Notice that trying to control "ov" directly by a group element will not
work since "ov" controls multiple elements.

A "group" can be used to control an elements position and length
using one of the following attributes:
  accordion_edge  ! Element grows or shrinks symmetrically
  start_edge      ! Varies element's upstream edge s-position
  end_edge        ! Varies element's downstream edge s-position
  s_position      ! Varies element's overall s-position. Constant length.
With "accordion_edge", "start_edge", "end_edge", and "symmetric_edge" the longitudinal
position of an elements edges are varied. This is done by appropriate control of the element's
length and the lengths of the elements to either side. In all cases the total length of the lattice
is kept invariant.

As an example, consider "accordion_edge" which varies the edges of an element so that the center
of the element is fixed but the length varies:
  gr: group = {Z[accordion_edge]:1}, var = {offset}
A change of, say, 0.1 "gr"'s "offset" variable moves both edges of element "Z" by 0.1
meters so that the length of "Z" changes by 0.2 meters but the center of "Z" is constant. To
keep the total lattice length invariant, the lengths of the elements to either side are decreased by
0.1 meters to keep the total lattice length constant.
  q10: quad, l = ...
  q11: quad, l = ...
  d1: drift, l = ...
  d2: drift, l = ...
  this_line: line = (... d1, q10, d2, q11, ...)
  gr2: group = {q10[start_edge]:1}, var = {a}, a = 0.1
The effect of  "gr2[a]" will be to lengthen the length of
"q10" and shorten the length of "d1".

A lattice file may contain lines and lattice elements that are not part of the actual finished
lattice when the lattice is constructed. "Group" elements where \em none of its slave elements
are part of the finished lattice are ignored and are also not part of the finished lattice.  When a
"group" element has some slave elements that are part of the finished lattice and some slave
elements that are not, the "group" element as implemented in the finished lattice will only
control slave elements that actually exist in the finished. In any case, a slave element that a
"group" element references must be defined (but not necessarily be used in the finished lattice)
in the lattice file. This rule is enforced in order to catch spelling mistakes.

If the arithmetical expression used for an "group" contains an element attribute, care must be
taken if that element attribute is changed. This is discussed in and
.

###section Hybrid

A "hybrid" element is an element that is formed by a program by concatenating other element
together. "Hybrid" elements are used to reduce the number of elements in a lattice to speed up a
simulation. In terms of tracking a "hybrid" element is essentially the same as a "taylor"
element.

###section Instrument, Monitor, and Pipe

Essentially Bmad treats "instrument", "monitor", and "pipe" elements like a
"drift". There is a difference, however, when superimposing elements . For
example, a "quadrupole" superimposed on top of a "drift" results in a free "quadrupole"
element in the tracking part of the lattice and no lord elements are created. On the other hand, a
"quadrupole" superimposed on top of a "monitor" results in a "quadrupole" element in the
tracking part of the lattice and this "quadrupole" element will have two lords: A "quadrupole"
superposition lord and a "monitor" superposition lord. The exception is if a "instrument",
"monitor", and "pipe" is superimposed with an element with non-constant reference energy like
a "lcavity". In this case no "instrument", "monitor", or "pipe" "super_lord" element
is made.

General "instrument", "monitor", and "pipe" attributes are:
\tt
  \sl Attribute Class      Section             \sl Attribute Class      Section          
  Aperture limits            \refs:limit       Is_on                      \refs:is.on   
  Chamber wall               \refs:wall        Length                     \refs:l       
  Custom Attributes          \refs:cust.att    Offsets, pitches \& tilt   \refs:offset   
  Description strings        \refs:alias       Reference energy           \refs:energy  
  Hkick \& Vkick             \refs:kick        Superposition              \refc:super   
  Instrumental variables     \refs:meas.attrib Symplectify                \refs:symp    
  Integration settings       \refs:integ       Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

The "offset", "pitch", and "tilt" attributes are not
used by any Bmad routines. If these attributes are used by a program
they are typically used to simulate such things as measurement
offsets. The "is_on" attribute is also not used by Bmad
proper. Example:
  d21: instrum, l = 4.5

###section Kickers: Hkicker and Vkicker

An "hkicker" gives a beam a horizontal kick and a "vkicker" gives a 
beam a vertical kick. Also see the "kicker"  element.

General "hkicker" "vkicker" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Is_on                      \refs:is.on   
  Chamber wall               \refs:wall      Length                     \refs:l       
  Custom Attributes          \refs:cust.att  Mag \& Elec multipoles     \refs:multip  
  Description strings        \refs:alias     Offsets, pitches \& tilt   \refs:offset  
  Field Maps                 \refs:fieldmap  Reference energy           \refs:energy   
  Fringe Fields              \refs:fringe    Superposition              \refc:super   
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp    
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Note that "hkicker" and "vkicker" elements use the
"kick" attribute while a "kicker" uses the "hkick" and "vkick" 
attributes. Example:
  h_kick: hkicker, l = 4.5, kick = 0.003

###section Kicker

A "kicker" can deflect a beam in both planes. Note that a "kicker" uses the "hkick" and
"vkick" attributes while "hkicker" and "vkicker" elements use the "kick" attribute.  In
addition, a "kicker" can apply a displacement to a particle using the "h_displace" and
"v_displace" attributes.

General "kicker" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section           
  Mag \& Elec multipoles     \refs:multip    Length                     \refs:l        
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset   
  Chamber wall               \refs:wall      Overlapping Fields         \refs:overlap  
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy    
  Description strings        \refs:alias     Superposition              \refc:super    
  Fringe Fields              \refs:fringe    Symplectify                \refs:symp     
  Hkick \& Vkick             \refs:kick      Field Maps                 \refs:fieldmap 
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods   
  Is_on                      \refs:is.on                                                 
  
\toffset
See for a full list of element attributes along with a their units.

Example:
  a_kick: kicker, l = 4.5, hkick = 0.003

###section Lcavity

An "lcavity" is a LINAC accelerating cavity.  The main difference between an "rfcavity" and an
"lcavity" is that, unlike an "rfcavity", the reference energy  through
an "lcavity" is not constant.

General "lcavity" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset     
  Chamber wall               \refs:wall      Overlapping Fields         \refs:overlap    
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy      
  Description strings        \refs:alias     RF Couplers                \refs:rf.coupler 
  Field autoscaling          \refs:autoscale Superposition              \refc:super      
  Fringe Fields              \refs:fringe    Symplectify                \refs:symp       
  Hkick \& Vkick             \refs:kick      Field Maps                 \refs:fieldmap   
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods    
  Is_on                      \refs:is.on     Wakes                      \refs:wakes      
  Length                     \refs:l                                                       
  
\toffset
See for a full list of element attributes along with a their units.

The attributes specific to an "lcavity" are 
  cavity_type     = <Switch>  ! Type of cavity.
  gradient        = <Real>    ! Accelerating gradient (V/m).
  gradient_err    = <Real>    ! Accelerating gradient error (V/m).
  gradient_tot                ! Net gradient = gradient + gradient_err. Dependent param .
  phi0            = <Real>    ! Phase (rad/2\pi) of the reference particle with 
                              !   respect to the RF. phi0 = 0 is on crest.
  phi0_autoscale              ! Set by Bmad when autoscaling is turned on.
  phi0_multipass  = <Real>    ! Phase (rad/2\pi) with respect to a multipass lord .
  phi0_err        = <Real>    ! Phase error (rad/2\pi)
  e_loss          = <Real>    ! Loss parameter for short range wakefields (V/Coul).
  rf_frequency    = <Real>    ! RF frequency (Hz).
  field_autoscale             ! Set by Bmad when autoscaling is turned on.
  voltage                     ! Cavity voltage. Dependent attribute .
  voltage_err                 ! Error voltage
  voltage_tot                 ! Net voltage = voltage + voltage_err. Dependent param .
  l_active        = <Real>    ! Active region length. Dependent attribute .
  n_cell          = <Int>     ! Number of cavity cells. Default is 1.
  longitudinal_mode = <Int>   ! Longitudinal mode. Default is 1. May be 0 or 1.

The "voltage" and "voltage_err" attributes can be used in place of "gradient" and "gradient_err".
The relationship between gradient and voltage is
  voltage     = L * gradient
  voltage_err = L * gradient_err

The energy kick felt by a particle, assuming no phase slippage, is 
  dE = r_q * gradient_tot * L * cos(2\,\pi * (\phi_t + \phi_\REF))
where r_q is the charge of the particle relative to the charge of the reference particle.
where the total gradient is
  gradient_tot = (gradient + gradient_err) * field_autoscale
\phi_t is the part of the phase due to when the particle arrives at the cavity and depends upon
whether "absolute time tracking" or "relative time tracking" is being used as discussed in
. The phase \phi_\REF is
  \phi_\REF = phi0 + phi0_multipass + phi0_err + phi0_autoscale

In the above equation r_q is the relative charge between the reference particle (set by the
"parameter[particle]" parameter in a lattice file) and the particle being tracked through the
cavity. For example, if the reference particle and and the tracked particle are the same, r_q is
unity independent of the type of particle tracked.

"phi0_multipass" is only to be used with multipass to shift the phase of the cavity from pass to
pass. See.

"phi0_autoscale" and "field_autoscale" are calculated by Bmad's auto-scale module. See
Section~ for more details. Autoscaling can be toggled on/off by using the
"autoscale_phase" and "autoscale_amplitude" toggles.

The energy change of the reference particle is just the energy change for a 
particle with z = 0 and no phase or gradient errors. Thus
  dE(reference) = gradient * L * cos(2\,\pi * \phi_\REF)

The energy kick for a Bmad "lcavity" is consistent with MAD. 
Note: The MAD8 documentation for an "lcavity" has a wrong
sign. Essentially the MAD8 documentation gives
  dE = gradient * L * cos(2\,\pi * (\phi_\REF - phi(z))) ! WRONG
This is incorrect. 

When short-range wakefields are being simulated, with "bmad_com%sr_wakes_on = True"
, the "e_loss" attribute can be used to modify the gradient in order to
maintain a constant average energy gain. That is, "e_loss" can be used to simulate the effect of
a feedback circuit that attempts to maintain the average energy of the bunch after the element
constant.  The energy kick is then
  dE(with wake) = dE + e_loss * n_part * e_charge 
"n_part" is set using the "parameter" statement  and represents the number of
particles in a bunch. "e_charge" is the magnitude of the charge on an electron
(Table~\reft:constants). Notice that the "e_loss" term is independent of the sign of the charge
of the particle.

The "cavity_type" is the type of cavity being simulated. Possible
settings are:
  ptc_standard
  standing_wave    ! Default
  traveling_wave
The "cavity_type" switch is ignored if a field map is used.  With the "standing_wave" setting,
the transverse trajectory through an "lcavity" is modeled using equations developed by Rosenzweig
and Serafini\citeb:rosenzweig modified to give the correct phase-space area at non
ultra-relativistic energies.  See Section for more details.  Note: The transfer
matrix for an "lcavity" with finite "gradient" is never symplectic. See
. In addition, couplers  and HOM wakes  can
be modeled.

When an element's "tracking_method" is set to "runge_kutta", the fields used with
"field_calc" set to "bmad_standard" are described in Section~. With
"cavity_type" set to "standing_wave", the longitudinal mode is set by the
"longitudinal_mode" parameter. The possible values are 0 or 1 and the default setting is 0.

If an element's "cavity_type" parameter is set to "standing_wave", and if the "field_calc"
parameter is set to "bmad_standard", and if an element's "tracking_method" is set to
"runge_kutta" , the "active region" over which there is a finite field is
"n_cell" half-wave pillbox resonators where each pillbox has length \lambda/2
. The default setting for "n_cell" is 1. The dependent parameter
"l_active" is set to the length of the active region. The active region should have a length less
than the length of the element. If the length of the element is not equal to the active region, the
active region is centered in the element and the regions to either side are treated as field free.

Note: When an element's "tracking_method" is set to "bmad_standard", settings for the
parameters "n_cell", and "longitudinal_mode" are ignored.

Example:
  lwf: lcavity, l = 2.3, rf_frequency = 500e6, voltage = 20e6,
         tracking_method = runge_kutta, n_cell = 3, longitudinal_mode = 1

\em Note: The default "bmad_standard" tracking for "lcavity" elements when the velocity
\beta is significantly different from 1 can only be considered as a rough approximation. Indeed,
the only accurate way to simulate a cavity in this situation is by integrating through the actual
field [Cf.~Runge Kutta tracking ]

###section Lens

A "lens" is an element for concentrating or dispersing light rays.

This element is under development...

###section Marker

A "marker" is a zero length element meant to mark a position. 

General "marker" attributes are:
\tt
  \sl Attribute Class      Section             \sl Attribute Class        Section          
  Aperture limits            \refs:limit       Is_on                        \refs:is.on    
  Chamber wall               \refs:wall        Offsets \& tilt              \refs:offset  
  Custom Attributes          \refs:cust.att    Reference energy             \refs:energy  
  Description strings        \refs:alias       Superposition                \refc:super   
  Instrumental variables     \refs:meas.attrib Tracking \& transfer map     \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

The "x_offset", "y_offset" and "tilt" attributes are not used
by any Bmad routines. Typically, if these attributes are used by a
program, they are used to simulate things like BPM offsets. The
"is_on" attribute is also not used by Bmad proper. 

Example:
  mm: mark, type = "BPM"

###section Mask

A "mask" element defines an aperture where the mask area can
essentially have an arbitrary shape. 

For X-ray tracking, a "mask" element is similar to a
"diffraction_plate"  element except that with
a "diffraction_plate" element, coherent effects are taken into
account while, with a "mask" element, coherent effects are ignored.
Also a "mask" element can be used with charged particles while a
"diffraction_plate" cannot.

General "mask" element attributes are:
\tt 
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset  
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy  
  Description strings        \refs:alias     Superposition              \refc:super   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Notice that, unlike a "rcollimator" or a "ecollimator", a "mask" element has zero length.

Attributes specific to a "mask" element are:
  mode               = <Type>   ! Reflection or transmission (photon tracking only).
  field_scale_factor = <Real>   ! Factor to scale the photon field.
  ref_wavelength                ! Reference wavelength . Dependent attrib .
  wall               = {...}    ! Defines mask geometry (\refs:wall, \refs:masking.wall).

Note: These attributes are only pertinent for photon tracking. Charged
particle tracking assumes transmission mode and does not use
"field_scale_factor" and "ref_wavelength" attributes.

The "mode" switch, which is only used for photon tracking, sets
whether X-rays are transmitted through the "mask" or
or reflected. Possible values for the "mode" switch are:
  reflection
  transmission        ! Default

The geometry of the mask, that is, where the openings (in transmission mode) or reflection regions
are, is defined using the "wall" attribute. See and \refs:masking.wall for more
details.

In transmission mode, a "mask" is nominally orientated transversely to the beam. Like all other
elements, the "mask" can be reoriented using the element's offsets, pitches and tilt attributes
.

The "aperture_type"  parameter of a "mask" will default to "auto" which
will set the aperture limits to define a rectangular aperture that just cover the clear area of the
mask.

The "field_scale_factor", if set to a non-zero value (zero is the
default) will be used to scale the field of photons as they pass through
the "mask" element:
  field -> field * field_scale_factor
Scaling is useful since the electric field of photons traveling through a "mask" are renormalized
(see \Eqseeo4p and \eqeek4p). This can lead to large variation of the photon field and can, for
example, make visual interpretation of plots of field verses longitudinal position difficult to
interpret. "field_scale_factor" can be used to keep the field more or less constant.

A "mask" that is "turned off" ("is_on" attribute set to False), does not mask at all and
transmits everything.

Example:
scrapper: mask, mode = transmission, wall = {
    section = {type = clear, v(1) = {0.9, 0.5}},
    section = {type = opaque, r0 = (0, 0.4), v(1) = {0.1, 0.1}}
  }

###section Match

A "match" element is used to match the Twiss parameters between two
points. 

General "match" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Length                     \refs:l       
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy   
  Description strings        \refs:alias     Superposition              \refc:super    
  Is_on                      \refs:is.on                                                
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "match" element are:
  beta_a0, beta_b0   = <Real>            ! Entrance betas
  beta_a1, beta_b1   = <Real>            ! Exit betas
  alpha_a0, alpha_b0 = <Real>            ! Entrance alphas
  alpha_a1, alpha_b1 = <Real>            ! Exit alphas
  eta_x0, eta_y0     = <Real>            ! Entrance etas 
  eta_x1, eta_y1     = <Real>            ! Exit etas 
  etap_x0, etap_y0   = <Real>            ! Entrance momentum dispersion
  etap_x1, etap_y1   = <Real>            ! Exit eta'
  c11_mat0, c12_mat0, c21_mat0, c22_mat0 = <Real>  ! Entrance coupling.
  c11_mat1, c12_mat1, c21_mat1, c22_mat1 = <Real>  ! Exit coupling.
  mode_flip0, mode_flip1 = <T/F>         ! Mode flip status . Default: False.
  dphi_a, dphi_b            = <Real>     ! Phase advances (radians).
  x0, px0, y0, py0, z0, pz0 = <Real>     ! Entrance coordinates
  x1, px1, y1, py1, z1, pz1 = <Real>     ! Exit coordinates
  delta_time                = <Real>     ! Change in time.
  matrix                    = <Switch>   ! Matrix calculation. Default: standard.
  kick0                     = <Switch>   ! Zeroth order calc. Default: standard.
  spin_tracking_model       = <Switch>   ! How to track the spin?
  recalc                    = <Logical>  ! Calculate transfer map? Default is True.

The transfer map for a "match" element is a first order transformation:
  r_1 = M \, r_0 + V 
where r_1 is the output coordinates, and r_0 are the input coordinates. The matrix M is
the linear part of the map and the vector V is the zeroth order ("kick") part of the map.

Nomenclature: The parameters "beta_a0", "alpha_a0", etc. of the "match" element are called
the entrance (upstream) "element" Twiss parameters. The parameters "beta_a1", "alpha_a1",
etc. of the "match" element are called the exit (downstream) "element" Twiss
parameters. Similarly, "c11_mat0", etc. are the entrance components of the C coupling
matrix  and "c11_mat1" are the exit end element values. These parameters in
general will be different from the actual computed Twiss and coupling parametersat the ends of the
"match" element.

The "matrix" switch determines how the linear M matrix is calculated. Possible settings of this
parameter are:
  match_twiss      ! Element entrance Twiss set to actual Twiss to match exit end values.
  identity         ! \fM is set to the unit matrix.
  phase_trombone   ! Element Twiss are set so that \fM produces a pure phase shift.
  standard         ! Use element values to calc matrix (default).

     standard 
With "matrix" set to "standard" (the default), the matrix M is calculated such that if
(and only if) the actual Twiss and coupling parameters at the entrance of the "match" element
are equal to the element entrance Twiss and coupling parameters, then the computed Twiss and
coupling parameters at the exit end of the "match" element will be the element end Twiss and coupling
parameters. Additionally, the phase advances (in radians) will be "dphi_a" and "dphi_b". Exception:
If "beta_a0", "beta_b0", "beta_a1", and "beta_b1" are all zero, the matrix will be set to the
identity.

     identity 
With "matrix" set to "identity" the transfer matrix will be set to the unit matrix independent
of the element Twiss and coupling settings.

     match_twiss 
The "match_twiss" setting for "matrix" instructs Bmad, when a program is run, to set the
element entrance Twiss and coupling values to the computed Twiss and coupling values from the exit
end of the previous element. This ensures that the computed Twiss and coupling at the element's exit end
will correspond to the element Twiss and coupling values. This is only done if "recalc" is set to
True (the default). If "recalc" is False, no element Twiss and coupling parameters are modified
and the transfer matrix is calculated from the element Twiss and coupling parameters the same as the
"standard" setting.

"match_twiss" with "recalc" set to True can only be used with lattices with an "open"
geometry  since, for a "closed" lattice, it is not possible to calculate the
Twiss parameters at the previous element independently of the element end Twiss parameters at the
"match" element.

When running a program, if a "match" element initially has "matrix" set to "match_twiss" and
"recalc" is set to True, the Bmad bookkeeping routines will ensure that the "match" element's
entrance element Twiss parameters are appropriately set as explained above. If "recalc" is now
toggled to False (which is done automatically, for example, by the Tao program), the entrance Twiss attribute
values, and hence the transfer matrix for the "match" element, will be frozen. Thereafter,
variation of any parameter in the lattice that affects the calculated Twiss parameters at the
entrance of the "match" element will not affect the "match" element's transfer matrix.

     phase_trombone 
The "phase_trombone" setting for "matrix" is conceptually similar to the "match_twiss". The
difference is that with "phase_trombone", Bmad will modify both the entrance and exit element
parameters so that the actual entrance Twiss and coupling equals the actual exit Twiss and coupling
and there will be a phase advance through the match element that is set by "dphi_a" and
"dphi_b" for the a and b modes respectively.

Like the "match_twiss" setting, the "recalc" parameter determines if Bmad will modify the element
parameters.

Note: With "match_twiss" and "phase_trombone" settings the element's Twiss and coupling parameters
are modified. With "identity" and "standard" the element parameters are not varied.

Note: There is an old notation with logical parameters "match_end" and "phase_trombone"
instead of "matrix" and "recalc".  The correspondence is
  match_end   phase_trombone    matrix           recalc
  ---------   --------------    --------------   ------
  False       False             standard         False or True
  True        False             match_twiss      True
  False       True              phase_trombone   True
The setting of "match_end" and "phase_trombone" both True is not allowed.

The setting of the "kick0" paramter determines how the zeroth order transfer map vector V is
constructed. Possible settings of this parameter are:
  match_orbit    ! Element entrance orbit set to actual orbit to match exit end values.
  zero           ! Set V zero.
  standard       ! Use element orbit values to calc V (default).

     standard 
With "kick0" set to "standard" (the default), the vector V is set so that if a particle
enters the "match" element with position "(x0, px0, y0, py0, z0, pz0)" the element position
at the exit end will be "(x1, px1, y1, py1, z1, pz1)". With this, V will be:
  V = 
    \textx1  \textpx1  \texty1  \textpy1  \textz1  \textpz1 
    M \, \beginpmatrix 
    \textx0  \textpx0  \texty0  \textpy0  \textz0  \textpz0 

     match_orbit 
The "match_orbit" setting for "kick0" instructs Bmad, when a program is run, to set the element
entrance position to the computed orbit from the exit end of the previous element. This ensures that
the computed orbit at the element's exit end will correspond to the position set in the
element. This is only done if "recalc" is set to True (the default). If "recalc" is False, no
element position values are modified and V is calculated from the element position the same as
the "standard" setting.

Like the situation with "match_twiss" set with "matrix", "match_orbit" with "recalc" set
to True can only be used with lattices with an "open" geometry  since, for a
"closed" lattice, it is not possible to calculate the Twiss parameters at the previous element
independently of the element end Twiss parameters at the "match" element.

     zero 
The "zero" setting for "kick0" sets V to zero independent of teh element position values.

Note: With the "match_orbit" setting the element's entrance orbit values will be modified. With
"zero" and "standard" settings the elements parameters will not be varied by Bmad.

The "delta_time" parameter adds a constant to the particle's time. This will also affect the z
phase space coordinate through \Eqzbctt and the transfer map though the element. If
"delta_time" is zero, the transfer map through the element will be the M matrix as
discussed above. With a finite "delta_time", the transfer map will be different from M.
The order of operations, is the effect of "delta_time" is applied first and the linear
transformation above is applied afterwards. Since using "match_twiss" or "match_orbit" with
a finite "delta_time" can be confusing, such a situation is not allowed. Use two separate
"match" elements if needed.

The settings of "spin_tracking_model" are:
  off               ! Spin direction does not change (default).
  transverse_field  ! Assumes a transverse magnetic field.
With a setting of "off" (the default), the spin does not change when a particle is tracked through the element.
With a setting of "transverse_field", it is assumed that the orbital transfer matrix is due solely to transverse
magnetic fields so that the integrated spin rotation (\Eqsorpt, \eqpqlbp1, and \eqpqlbp2) can
be related to the orbital transport via
  \int \pmb\Omega_BMT = \frac1 + a \gamma1 + p_z \, (-\Delta p_y, \Delta p_x, 0)
where \Delta p_x and \Delta p_y are the change in p_x and p_y when tracking through the match element
and the small angle approximation (p_x, p_y \ll 1) has been used.

A "match" element that is "turned off" ("is_on" attribute set to False), is considered to be
like a "marker" element. That is, the orbit, spin, and Twiss parameters are unchanged when tracking
through a "match" element that is turned off.

The length attribute "l" is not used in the transfer matrix calculation. The length "l" is
used to compute the time it takes to go through a match element.

Example:
  mm: match, beta_a1 = 12.5, beta_b1 = 3.4, eta_x1 = 1.0, matrix = match_twiss

###section Mirror

A "mirror" reflects photons. 

General "mirror" attributes are:
\tt 
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Reflection tables          \refs:reflect 
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Surface Properties         \refs:surface 
  Offsets, pitches \& tilt   \refs:offset    Tracking \& transfer map   \refc:methods  
  Reference energy           \refs:energy                                               
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "mirror" element are:
  graze_angle     = <Real>   ! Angle between incoming beam and mirror surface.
  critical_angle  = <Real>   ! Critical angle.
  ref_wavelength             ! Reference wavelength . Dependent attribute .

The reference trajectory for a
"mirror" is that of a zero length bend  and
hence the length ("l") parameter of a mirror is fixed at zero. The
reference trajectory is determined by the values of the
"graze_angle" and "ref_tilt" parameters. A positive "graze_angle"
bends the reference trajectory in the same direction as a positive
"g" for a bend element.

A "mirror" may be offset and pitched (\refs:offset). The incoming
local reference coordinates are used for these misalignments.

###section Multipole

A "multipole" is a thin magnetic multipole lens up to 21\St order. The basic
difference between this and an "ab_multipole" is the input
format. See section~ for how the multipole coefficients
are defined.

General "multipole" attributes are:
\tt 
  \sl Attribute Class          Section           \sl Attribute Class      Section          
  Aperture limits                \refs:limit     Reference energy           \refs:energy  
  Custom Attributes              \refs:cust.att  Is_on                      \refs:is.on    
  Chamber wall                   \refs:wall      Offsets, pitches \& tilt   \refs:offset  
  Description strings            \refs:alias     Tracking \& transfer map   \refc:methods  
  KnL, KnSL, Tn multipoles \refs:multip                                               
  
\toffset
See for a full list of element attributes along with a their units.

The length "l" is a fictitious length that is used for synchrotron
radiation computations and affects the longitudinal position of the
next element but does not affect any tracking or transfer map
calculations.

When an "multipole" is superimposed  on a lattice, it is
treated as a zero length element and in this case it is an error for the length
of the "multipole" to be set to a nonzero value.

Like a \mad "multipole", a Bmad "multipole" will affect the
reference orbit if there is a dipole component. 
Example:
  m1: multipole, k1l = 0.034e-2, t1, k3sl = 4.5, t3 = 0.31*pi

###section Multilayer_mirror

A "multilayer_mirror" is a substrate upon which multiple layers of alternating substances have
been deposited. The idea is similar to crystal diffraction: light reflected at each interface
constructively interferes with light reflected from other interfaces. The amplified reflection
offsets losses due to absorption.

General "crystal" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Symplectify                \refs:symp    
  Custom Attributes          \refs:cust.att  Offsets, pitches \& tilt   \refs:offset  
  Description strings        \refs:alias     Superposition              \refc:super   
  Reference energy           \refs:energy    Tracking \& transfer map   \refc:methods 
  Surface Properties         \refs:surface                                              
  
\toffset

The attributes specific to a "multilayer_mirror" are 
  material_type    = <String>  ! Materials in each layer.
  d1_thickness     = <Real>    ! Thickness of layer 1
  d2_thickness     = <Real>    ! Thickness of layer 2
  n_cell           = <Integer> ! Number of cells (= Number of layers / 2)
  ref_wavelength               ! Reference wavelength . Dependent attribute .
See for a full list of element attributes along with a their units.

Dependent attributes  are
  graze_angle      ! Angle between incoming beam and mirror surface.
  v1_unitcell      ! Unit cell volume for layer 1
  v2_unitcell      ! Unit cell volume for layer 2 

A "multilayer_mirror" is constructed of a number of "cells". The
number of cells is set by "n_cell". Each cell consists of two
layers of dielectric material. The materials used is given by
the "material_type" attribute. The format for this is
  material_type = "<material_1>:<material_2>"
where "<material_1>" and "<material_2>" are the material names
for the first and second layers of the cell respectively. The first
layer is the bottom layer and the second layer is the top layer of the
cell.  Material names are case sensitive. So "FE" cannot be used in
place of "Fe" A list of materials is given in
and can include crystal materials or elemental materials.

Example:
  mm: multilayer_mirror, material_type = "W:BORON_CARBIDE", n_cell = 100, &
            d1_thickness = 1e-9, d2_thickness = 1.5e-9
  m2: multi    ! This is a multipole element!! 
Note: Due to the fact that "multilayer_mirrors" where introduced much later than "multipole"
elements, if there is an ambiguity in the name as shown in the above example, an element will be
considered to be of type "multipole".

###section Null_Ele

A "null_ele" is a special type of element. It is like a "marker" but it has the property that
when the lattice is expanded  all "null_ele" elements are removed. The
primary use of a "null_ele" is in computer generated lattices where it can be used to serve as a
reference point for element superpositions . Another use is to split an element
using superposition while avoiding having to add a marker element to the lattice. Example:
  N: null_ele, superimpose, ref = quadrupole::*
This will split all quadrupoles in the lattice in two.

"Null_ele" elements are not generally useful otherwise.

###section Octupole

An "octupole" is a magnetic element with a cubic field dependence
with transverse offset .  The "bmad_standard"
calculation treats an octupole using a kick--drift--kick model.

General "octupole" attributes are:
\tt
  \sl Attribute Class      Section             \sl Attribute Class      Section             
  Aperture limits            \refs:limit       Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall        Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att    Overlapping Fields         \refs:overlap    
  Description strings        \refs:alias       Reference energy           \refs:energy      
  Fringe Fields              \refs:fringe      Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick        Symplectify                \refs:symp       
  Integration settings       \refs:integ       Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on       Tracking \& transfer map   \refc:methods     
  Length                     \refs:l                                                         
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "octupole" element are:
  k3           = <Real>   ! Octupole strength.
  b3_gradient  = <Real>   ! Field strength. .
  field_master = <T/F>    ! See.
The normalized octupole "k3" strength is related to the unnormalized "b3_gradient" field
strength through \Eqkqlbp.

If the "tilt" attribute is present without a value then a value of 
\pi/8 is used.
Example:
  oct1: octupole, l = 4.5, k3 = 0.003, tilt ! same as tilt = pi/8

###section Overlay

"Overlay" elements are a type of "control" element  used to make
variations in the attributes of other elements (called "slave" attributes) while a program is
running. For example, to simulate the action of a magnet power supply that controls a string of
magnets. Also see "group"  The difference between "group" and "overlay"
elements is that "overlay" elements set the values of the attributes directly while "group"
elements make delta changes to attribute values.

General "overlay" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Is_on                      \refs:is.on   
  Description strings        \refs:alias                                                 
  
\toffset
See for a full list of element attributes along with a their units.

There are two types of "overlay" elements: "Expression" based and "knot" based.
The general syntax for a "expression" based "overlay" element is
  name: OVERLAY = {ele1[attrib1]:exp1, ele2[attrib2]:exp2, ...}, 
              VAR = {var1, var2, ...}, var1 = init_val1, old_var1 = init_val_old1, ...
where "ele1"["attrib1"], "ele2"["attrib2"], etc. specify the slave attributes and
"exp1", "exp2", etc. are the arithmetical expressions, that are functions of "var1",
"var2", etc., and are used to determine a value for the slave attributes.

The general syntax for a "knot" based "overlay" element is
  name: OVERLAY = {ele1[attrib1]:{y_knot_points1}, ele2[attrib2]:{y_knot_points2}, ...}, 
              VAR = {var1}, X_KNOT = {x_knot_points}, INTERPOLATION = {type},
              var1 = init_val1, ...

\textbfSee Section~ for a detailed description of this syntax.

An "overlay" element is used to control the attributes of other elements. If multiple
"overlays" control the same slave parameter, the parameter value will be the
sum of the values set by the individual "overlays". For example:
  over1: overlay = {a_ele, b_ele:2.0}, var = {hkick}, hkick = 0.003
  over2: overlay = {b_ele}, var = {hkick}
  over2[hkick] = 0.9
  a_ele: quad, hkick = 0.05   ! NO: Cannot control slave attributes of overlays
  b_ele: rbend, ...
  this_line: line = (... a_ele, ... b_ele, ...)
  use, this_line

In the example the overlay "over1" controls the "hkick" attribute of the "slave" elements
"a_ele" and "b_ele". "over2" controls the hkick attribute of just
"b_ele". "over1[hick]" has a value of 0.003 and "over2[hkick]" has been assigned a value of
0.9. Thus:
  a_ele[hkick] = over1[hkick]
               = 0.003
  b_ele[hkick] = over2[hkick] + 2 * over1[hkick] 
               = 0.906

Overlays completely determine the value of the attributes that are controlled by the overlay. in the
above example, the hkick of 0.05 assigned directly to "a_ele" is overwritten by the overlay
action of "over1".

\noindent The default value for an overlay is 0 so for example
  over3: overlay = {c_ele}, var = {k1}
will make "c_ele[k1]" = 0. 

As illustrated above, different "overlay" elements may control the same element attribute. And an
"overlay" element may control other "overlay", "group" or "girder" elements. However, It
does not make sense for an "overlay" element to control the same attribute as a "group"
element or for an "overlay" element to control a "dependent" attribute .

The "is_on" parameter may be set for an overlay. If set to "False", the "overlay" will be
ignored. If all the overlays controlling a given attribute are turned off, the attribute can be
set directly just like if there were no controlling overlays to begin with. Example:
  abc: overlay = { ... }, ...
  abc[is_on] = F

A lattice file may contain lines and lattice elements that are not part of the actual finished
lattice when the lattice is constructed. "Group" elements where \em none of its slave elements
are part of the finished lattice are ignored and are also not part of the finished lattice.  When a
"group" element has some slave elements that are part of the finished lattice and some slave
elements that are not, the "group" element as implemented in the finished lattice will only
control slave elements that actually exist in the finished. In any case, a slave element that a
"group" element references must be defined (but not necessarily be used in the finished lattice)
in the lattice file. This rule is enforced in order to catch spelling mistakes.

If the arithmetical expression used for an "overlay" contains an element attribute, care must be
taken if that element attribute is changed. This is discussed in and
.

###section Patch

  \includegraphics[width=5in]patch.pdf
A) A "patch" element can align its exit face arbitrarily with respect to its entrance face. The
red arrow illustrates a possible particle trajectory form entrance face to exit face. B) The
reference length of a "patch" element, if "ref_coords" is set to the default value of
"exit_end", is the longitudinal distance from the entrance origin to the exit origin using the
reference coordinates at the exit end as shown. If "ref_coords" is set to "entrance_end", the
length of the patch will be equal to the "z_offset".

A "patch" element shifts the reference orbit and time. Also see "floor_shift"
 and "fiducial"  elements. A common application of a patch
is to orient two lines with respect to each other. For example, to orient an injection line with the
ring it is injecting into .

General "patch" element attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset   
  Chamber wall               \refs:wall      Reference energy           \refs:energy  
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods 
  Length                     \refs:l                                                    
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "patch" elements are:
  x_offset        = <Real>    ! Exit face offset from Entrance.
  y_offset        = <Real>    ! Exit face offset from Entrance.
  z_offset        = <Real>    ! Exit face offset from Entrance.
  t_offset        = <Real>    ! Reference time offset.
  x_pitch         = <Real>    ! Exit face orientation from Entrance.
  y_pitch         = <Real>    ! Exit face orientation from Entrance.
  tilt            = <Real>    ! Exit face orientation from Entrance.
  E_tot_offset    = <Real>    ! Reference energy offset (eV).
  E_tot_set       = <Real>    ! Reference energy at exit end (eV).
  flexible        = <T/F>     ! Default: False.
  p0c_set         = <Real>    ! Reference momentum at exit end (eV).
  ref_coords      = <Switch>  ! Coordinate system defining the length.
  user_sets_length = <T/F>    ! User sets element length? Default is F.
  l               = <Real>    ! Reference length. 

A straight line element like a "drift" or a "quadrupole" has the exit face parallel to the
entrance face. With a "patch" element, the entrance and exit faces can be arbitrarily oriented
with respect to one another as shown in \figf:patchA.

There are two different ways the orientation of the exit face is determined. Which way is used is
determined by the setting of the "flexible" attribute.  With the "flexible" attribute set to
"False", the default, The exit face of the "patch" will be determined from the offset, tilt
and pitch attributes as described in. This type of "patch" is called
"rigid" or "inflexible" since the geometry of the "patch" is solely determined by the
"patch"'s attributes as set in the lattice file and is independent of everything else. Example:
  pt: patch, z_offset = 3.2   ! Equivalent to a drift

With "flexible" set to "True", the exit face is taken to be the reference frame of the
entrance face of the next element in the lattice. In this case, it must be possible to compute the
reference coordinates of the next element before the reference coordinates of the "patch" are
computed. A "flexible" "patch" will have its offsets, pitches, and tilt as dependent
parameters  and these parameters will be computed appropriately. Here the
"patch" is called "flexible" since the geometry of the patch will depend upon the geometry of
the rest of the lattice and, therefore, if the geometry of the rest of the lattice is modified (is
"flexed"), the geometry of the "patch" will vary as well. See Section~ for an
example.

The coordinates of the lattice element downstream of a "flexible" "patch" can be computed
if there is a "fiducial" element  somewhere downstream or if there is a
"multipass_slave"  element which is just downstream of the "patch" or at
most separated by zero length elements from the "patch". In this latter case, the
"multipass_slave" must represent an N\Th pass slave with N greater than 1. This works since
the first pass slave will be upstream of the "patch" and so the first pass slave will have its
coordinates already computed and the position of the downstream slave will be taken to be the same
as the first pass slave. Notice that, without the "patch", the position of multipass slave
elements are independent of each other.

With "bmad_standard" tracking  A particle, starting at the upstream face of the
"patch", is propagated in a straight line to the downstream face and the suitable coordinate
transformation is made to translate the particle's coordinates from the upstream coordinate frame to
the downstream coordinate frame . In this case the "patch" element can be
thought of as a generalized "drift" element.

If there are magnetic or electric fields within the "patch", the tracking method through the
"patch" must be set to either "runge_kutta" or "custom". Example:
  pa2: patch, tracking_method = runge_kutta, field_calc = custom, 
              mat6_calc_method = tracking, ...
In order to supply a custom field when "runge_kutta" tracking is used, "field_calc"
 needs to be set to "custom". In this case, custom code must be supplied for
calculating the fields as a function of position .

The "E_tot_offset" attribute offsets the
reference energy:
  E_tot_ref(exit) = E_tot_ref(entrance) + E_tot_offset (eV)
Setting the "E_tot_offset" attribute will affect a particle's p_x, p_y and p_z coordinates
via \Eqsppp and \eqppppp.  Notice that "E_tot_offset" does not affect a particle's actual
energy, it just affects the difference between the particle energy and the reference energy.

Alternatively, to set the reference energy, the "E_tot_set" or "p0c_set" attributes can be
used to set the reference energy/momentum at the exit end. It is is an error if more than one of
"E_tot_offset", "E_tot_set" and "p0c_set" is nonzero.

"Important": Bmad may apply the energy transformation either before or after the coordinate
transformation. This matters when the speed of the reference particle is less than c. For this
reason, and due to complications involving PTC, it is recommended to use two patches in a row when
both the orbit and energy are to be patched.

A "patch" element can have an associated electric or magnetic field . This can
happen, for example, if a patch is used at the end of an injection line to match the reference
coordinates of the injection line to the line being injected into  and the patch
element is within the field generated by an element in the line being injected into. In such a case,
it can be convenient to set what the reference coordinates are since the orientation of any fields
that are defined for a patch element will be oriented with respect to the patch element's reference
coordinates. For this, the "ref_coords"
parameter of a patch can be used. Possible settings are:
"ref_coords" are:
  entrance_end   
  exit_end      ! Default
The default setting of "ref_coords" is "exit_end" and with this the reference coordinates are
set by the exit end coordinate system (see \figf:patch). If "ref_coords" is set to
"entrance_end", the reference coordinates are set by the entrance end coordinate system. Example:
  p1: patch, x_offset = 1, x_pitch = 0.4   ! L = 0.289418 see below
  p2: p1, ref_coords = entrance_end        ! L = 0
Here "p1" has "ref_coords" set to "exit_end" (the default). "p2" inherits the parameters
of "p1" and sets "ref_coords" to "entrance_end".

It is important to keep in mind that if there are multiple patches in a row, while two different
configurations may be the same in a geometrical sense the total length may not be the same. For
example:
  pA: patch, x_offset = 1    ! L = 0
  pB: patch, x_pitch = 0.4   ! L = 0
  sum: line = (pA, pB)
The configuration of "pA" followed by "pB" is equivalent geometrically to the "p1" patch
above but the total length of the "(pA, pB)" line is zero which is different from the length of
"p1".

Unfortunately, there is no intuitive way to define the ""length"" "L" of a patch. This is
important since the transit time of the reference particle is the element length divided by the
reference velocity. And the reference transit time will affect how the phase space z coordinate
changes through the patch via \Eqzbctt. If the parameter "user_sets_length" is set to True, the
value of "l" set in the lattice file will be used (default is zero). "user_sets_length" is set
to False (the default), the length of a patch is calculated depending upon the setting of
"ref_coords".  If "ref_coords" is set to "exit_end", the length of the patch is calculated
as the perpendicular distance between the origin of the patch's entrance coordinate system and the
exit face of the patch as shown in \figf:patchB. If "ref_coords" is set to "entrance_end",
the length is calculated as the perpendicular distance between the entrance face and the origin of
the exit coordinate system. In this case, the length will be equal to "z_offset".

To provide flexibility, the "t_offset" attribute can be
used to offset the reference time. The reference time at the exit end of the patch
"t_ref(exit)" is related to the reference time at the beginning of the patch "t_ref(entrance)"
via
  t_ref(exit) = t_ref(entrance) + t_offset + dt_travel_ref
where "dt_travel_ref" is the time for the reference particle to travel through the patch.
"dt_travel_ref" is defined to be:
  dt_travel_ref = L / beta_ref
Where "L" is the length of the "patch" and "beta_ref" is the reference velocity/c at the
exit end of the element. That is, the reference energy offset is applied \em before the reference
particle is tracked through the patch. Since this point can be confusing, it is recommended that a
"patch" element be split into two consecutive patches if the "patch" has finite "l" and
"E_tot_offset" values.

While a finite "t_offset" will affect the reference time at the end of a patch, a finite
"t_offset" will \em not affect the time that is calculated for a particle to reach the end of
the patch. On the other hand, a finite "t_offset" will affect a particle's z coordinate via
\Eqszbctt. The change in z, \delta z will be
  \delta z = \beta \cdot c \cdot \textt_offset
where \beta is the normalized particle speed (which is independent of any energy patch). Another
way of looking at this is to note that In a drift, if the particle is on-axis and on-energy, t and
t_ref change but z does not change. In a time patch (a patch with only "t_offset" finite), t_ref
and z change but t does not.

When a lattice branch contains both normally oriented and reversed elements
, a "patch", or series of "patches", which reflects the z direction
must be placed in between. Such a "patch", (or patches) is called a "reflection" "patch".
See Section~ for more details on how a reflection patch is defined. In order
to avoid some confusing conceptual problems involving the coordinate system through a reflection
patch, Runge-Kutta type tracking is prohibited with a reflection patch.\footnote
  
In general, Runge-Kutta type tracking through a patch is a waste of time unless electric or magnetic
fields are present.
  
Since the geometry of a "patch" element is complicated, interpolation of the chamber wall in the
region of a patch follows special rules. See section~ for more details.

###section Photon_Init

A "photon_init" element is used as a starting element for x-ray tracking.  A "photon_init"
element can be used to define such things as the initial energy spectrum and angular orientation. As
explained below, a "photon_init" element can be a "stand alone" photon source or it can have an
associated "physical source" element.

Note: There is a utility program called "photon_init_plot" that comes with a Bmad Distribution
that will plot initial photon distributions and can be used as a check.

General "photon_init" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Aperture limits            \refs:limit     Length                     \refs:l       
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset  
  Custom Attributes          \refs:cust.att  Reference energy           \refs:energy   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods  
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "photon_init" element are:
  ds_slice                 = <Real>
  E_center                 = <Real>    ! Average init photon energy of 1st mode (eV).
  E2_center                = <Real>    ! Average init photon energy of 2nd mode (eV).
  E2_probability           = <Real>    ! Probability of 2nd mode.
  E_center_relative_to_ref = <T/F>     ! E_center relative to reference E? Default True.
  e_field_x                = <Real>    ! Polarization. x & y = 0 -> random
  e_field_y                = <Real>
  energy_distribution      = <Switch>  ! Gaussian, uniform, or curve.
  energy_probability_curve = {...}   ! Used with energy_distribution = curve. See below.
  physical_source          = <String>  ! physical source of x-rays
  ref_wavelength                       ! Ref wavelength . Dep attribute .
  sig_x                    = <Real>
  sig_y                    = <Real>
  sig_z                    = <Real>
  sig_vx                   = <Real>
  sig_vy                   = <Real>
  sig_E                    = <Real>    ! Init photon energy width of 1st mode (eV).
  sig_E2                   = <Real>    ! Init photon energy width of 2nd mode (eV).
  spatial_distribution     = <Switch>  ! Gaussian or uniform. 
  transverse_sigma_cut     = <Real>
  velocity_distribution    = <Switch>  ! Gaussian, spherical, or uniform. 

When the "energy_distribution" is set to "gaussian" or "uniform", the distribution of
photons is bimodal. The first mode is characterized by the parameters "E_center", and "sig_E",
the second mode is characterized by the parameters "E2_center" and "sig_E2". The probability
of emitting a photon in the second mode is given by "E2_probability".

       "ds_slice" 
Used when there is an associated physical source element. The physical source element is sliced into
pieces of thickness "ds_slice" and each slice is tested to see if photons from the slice can
possibly pass through the first aperture. When photons are generated, photons will only be generated
from slices where they have a hope of passing through the first aperture. This makes the simulation
more efficient.  The default value of "ds_slice" is 0.01 meter.

       "E_center", "E2_center" 
Average initial photon energy in eV. If "E_center_relative_to_ref" is set to True, "E_center"
and "E2_center" will be relative to the reference energy.

       "E_center_relative_to_ref" 
With a setting of True (the default), "E_center" and "E2_center" are taken to be with respect
to the reference energy . That is, if True, the center energy "<E>" is
  <E-1st-mode> = E1_center + Reference_Energy
  <E-2nd-mode> = E2_center + Reference_Energy
If "E_center_relative_to_ref" is set to False, "E_center" and "E2_center" are taken to be
the center energy values independent of the reference energy.

       "E2_probability" 
Probability of emitting a photon from the 2nd mode. A value of 0 (the default) will mean
that all photons will be emitted from the 1st mode and a value of 1 will mean that
all photons will be emitted from the 2nd mode.

       "e_field_x", "e_field_y" 
Electric field component of initial photons in the x and y planes. If both are set to 0 then a
random field is chosen with unit intensity E_x^2 + E_y^2 = 1.

       "energy_distribution" 
Sets the type of energy spectrum for emitted photons. If there is an associated physical element
then this parameter is ignored and the energy distribution is calculated from the properties of the
physical element. Possible settings are:
  gaussian   ! Default
  uniform
  curve
The "gaussian" setting gives Gaussian distributions for the two modes with width set by
"sig_E" and "sig_E2". The "uniform" setting gives a flat distribution in the range:
  [-sig_E, sig_E]    ! For the 1st mode
  [-sig_E2, sig_E2]  ! For the 2nd mode
The "curve" setting uses the energy probability curve set by the "energy_probability_curve"
component.

       "energy_probability_curve" 
The "energy_probability_curve" attribute provides a way to specify the energy probability
distribution when an Gaussian or uniform distribution is not suitable. The probability curve is
defined by specifying the curve at a number of points. The syntax is:
  energy_probability_curve = {E1 p1, E2 p2, ..., EN pN}
where the "E p" pairs are the energy and photon emissian probability at that energy. 
The commas between "E p" pairs is optional.
The probability curve does not have to be normalized, Bmad will take care of that. Bmad will
use cubic spline interpolation between points. 

       "physical_source" 
Used to specify the "physical" source of the photons. See below for more details

       "sig_E", "sig_E2" 
Energy width of the two modes in eV. See "energy_distribution" for more details.

       "sig_vx, sig_vy" 
Width of emitted photons in v_x/c and v_y/c directions. See
"velocity_distribution" for more details.

       "sig_x, sig_y, sig_z" 
Width of emitted photons in x, y and z directions. See
"spatial_distribution" for more details.

       "spatial_distribution" 
Sets spacial (x, y, z) spectrum of emitted photons. If there is an associated physical element
then this parameter is ignored and the energy distribution is calculated from the properties of the
physical element. Possible settings are:
  gaussian    ! Default
  uniform
The "gaussian" setting gives a Gaussian distribution with width
\sigma where \sigma is 
  sig_x     ! for x distribution
  sig_y     ! for y distribution
  sig_z     ! for z distribution
The "uniform" setting gives a flat
distribution in the range: [-\sigma, \sigma].

       "velocity_distribution" 
Sets the transverse (v_x/c, v_y/c) velocity spectrum of emitted photons. If there is an associated
physical element then this parameter is ignored and the energy distribution is calculated from the
properties of the physical element. The longitudinal velocity is always computed to make v_x^2 +
v_y^2 + v_z^2 = c^2 Possible settings are:
  gaussian    ! Default
  spherical
  uniform
The "gaussian" setting gives a Gaussian distribution with width
\sigma where sigma is 
  sig_vx     for vx/c distribution
  sig_vy     for vy/c distribution
The "uniform" setting gives a flat distribution in the range: [-\sigma, \sigma]. The
"spherical" setting gives flat distribution in all directions. With the "spherical"
setting is used, and the next downstream element excluding drifts and markers is an element
with aperture limits , Bmad can optimize photon emission to only emitting 
photons that are very likely to be within the aperture when they hit the downstream element.
This cuts down on computation time.

For the purposes of positioning the elements in the lattice around it,
a "photon_init" element is considered to have zero length.

"photon_init" elements are used in one of two modes: With or without an associated physical
source element specified by the "physical_source" attribute. Without an associated physical
source, the "photon_init" element completely specifies the initial photon distribution. With an
associated physical source element, the photon distribution is determined by the properties of the
physical source but the shape of the energy spectrum can be modified by setting attributes in the
"photon_init" element. Example:
  b05w: sbend, l = 3.2, angle = 0.1
  pfork: photon_fork, to_line = c_line, superimpose, ref = b05w, offset = 0.4
  bend_line: line = (..., b05w, ...)
  use bend_line

  c_line: line = (pinit, ...)
  c_line[E_tot] = 15e3
  pinit: photon_init, physical_source = "b05w", sig_E = 2.1
In this example, the bend "b05w" is a bend producing photons. It is part of the line
"bend_line". "bend_line" also contains a "photon_fork" element named "pfork" which
branches to the line "c_line". "c_line" contains the "photon_init" element "pinit" which
references "b03w" as the associated physical source element. When photons are tracked, they are
generated in "b05w" and then propagated to the "pfork" fork.  After this they are propagated
through "c_line". The "pinit" element acts like a zero length "marker" element when photons
propagate through it. That is, the "pinit" element essentially serves to associate "c_line"
with "b03w" for the purposes of photon tracking. Also, in this example, "pinit" modifies the
photon energy spectrum so that only photons whose energy is within 2.1 eV are generated

It is important to note that in the above example, with the "photon_init" element having an
associated physical source, the setting of things like the spatial shape "sig_z", etc. in the
"photon_init" element will be ignored.

See Section~ for an example lattice that can be used to simulate a Rowland circle
spectrometer using a "photon_init" element.

###section Quadrupole

A "quadrupole" is a magnetic element with a linear field dependence
with transverse offset .

General "quadrupole" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset     
  Description strings        \refs:alias     Overlapping Fields         \refs:overlap    
  Fringe Fields              \refs:fringe    Reference energy           \refs:energy      
  Hkick \& Vkick             \refs:kick      Superposition              \refc:super      
  Integration settings       \refs:integ     Symplectify                \refs:symp       
  Is_on                      \refs:is.on     Field Maps                 \refs:fieldmap    
  Length                     \refs:l         Tracking \& transfer map   \refc:methods     
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "quadrupole" element are:
  b1_gradient  = <Real>    ! Field strength. .
  k1           = <Real>    ! Quadrupole strength.
  fq1          = <Real>    ! Soft edge fringe parameter.
  fq2          = <Real>    ! Soft edge fringe parameter.
  field_master = <T/F>     ! See.
The normalized quadrupole "k1" strength is related to the unnormalized "b1_gradient" field
strength through \Eqkqlbp.

If the "tilt" attribute is present without a value then a value of \pi/4
is used.

For a quadrupole with zero "tilt" and a positive "k1", the
quadrupole is horizontally focusing and vertically defocusing
.

The "fq1" and "fq2" parameters are used to specify the
quadrupolar "soft" edge fringe. See for more details.
The "fringe_at" and "fringe_type" settings 
determine if the fringe field is used in tracking .

Example:
  q03w: quad, l = 0.6, k1 = 0.003, tilt  ! same as tilt = pi/4

###section Ramper

A "ramper" element is a type of "control" element . That is, a
"ramper" element can be used to make variations in the attributes of other elements while a
program is running. The "ramper" element is similar to an "overlay" element except that
"ramper" elements are designed to control large sets of elements. Also "ramper" elements can
be used to smoothly vary parameters as particle are propagated through a lattice. "Ramper"
elements where implemented to solve the problem of simulating machine ramping where the strength of
many elements in a machine are varied continuously as a function of time. The drawback of
"ramper" elements is that they can be only be used with programs that that are designed to handle
them.\footnote
  
In particular, the "long_term_tracking" program that is bundled with the Bmad software
 can handle "ramper" elements.
  
Ramper elements will be ignored in programs that are not designed to handle them. How a program
handles ramper elements will be program dependent and the program documentation should be consulted
for details.

Note: "ac_kicker" elements can also be used for simulating a time dependent element.

General "ramper" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  Custom Attributes          \refs:cust.att  Is_on                      \refs:is.on   
  Description strings        \refs:alias                                                 
  
\toffset
See for a full list of element attributes.

The syntax for "ramper" elements is exactly the same as for "overlay"  elements 
except that "ramper" elements do not have a "gang" attribute.

Like "overlay"s, There are two types of "ramper" elements: "Expression" based and
"knot" based.  The general syntax for a "expression" based "ramper" element is
  name: RAMPER = {ele1[attrib1]:coef1, ele2[attrib2]:coef2, ...}, VAR = {var1}
where "ele1[attrib1]", "ele2[attrib2]", etc. specify the slave attributes and "exp1",
"exp2", etc. are the arithmetical expressions, that are functions of "var1", "var2", etc.,
and are used to determine a value for the slave attributes.

The general syntax for a "knot" based  "ramper" element is
  name: RAMPER = {ele1[attrib1]:{y_knot_points1}, ele2[attrib2]:{y_knot_points2}, ...}, 
              VAR = {var1}, X_KNOT = {x_knot_points}, INTERPOLATION = {type},
              var1 = init_val1, ...

\textbfSee Section~ for a detailed description of this syntax.

Examples:
  ramp_e: ramper = {*[e_tot]:{4e+08, 4.00532e+08, 4.01982e+08, ...}},
                var = {time}, x_knot = {0, 0.001, 0.002, ...}, interpolation = cubic

  amp = 1e9;  omega = 0.167;  t0 = 0.053
  ramp_rf: ramper = {rfcavity::*[voltage]:amp*sin(omega *(t + t0)),
        rfcavity::*[phi0]:0.00158*t^2 + 3*q}, var = {t, q}
"Ramp_e" uses a cubic spline fit to interpolate between the knot points specified in the element
definition.  The ""*[e_tot]"" construct in the definition of "ramp_e" means that the ramper
will be applied to the "e_tot" attribute  of all elements (since the wild card
character ""*""  will match to all element names).

The "ramp_rf" ramper in the above example varies the "voltage" and "phase" ("phi0")
attributes of all elements that match to "rfcavity::*". That is, all "rfcavity" elements. Here
mathematical expressions are used instead of knot points.

"Ramper" elements can control the variables of other controller element except "rampers" are
not allowed to control "rampers". When a "ramper" controls variables in other controller
elements it is not permitted to use wild card characters. That is, in the above example, ""*""
will not match to any controller elements.

If a slave name contains wild card characters, for a given lattice element that the slave name
matches to, it is not required that the controlled attribute be a valid attribute of the element. In
the case where the controlled attribute is not valid for a given lattice element, no attributes of
the given lattice element are varied when and the ramper is varied. For example:
  rz: ramper = {*[k1]: ...
In this example the "k1" attribute of all those elements that have a "k1" attribute will be
controlled but something like a "sextupole" element which does not have a "k1" attribute will
not be controlled.

Due to the way bookkeeping is done for ramper elmeents, and unlike "group" or "overlay"
elements, it is not permitted for different "ramper" elements to control the same parameter of a
given slave element. Additionally, parameters that "ramper" elements control must not be
controlled by any "overlay" (but a "ramper" can control an "overlay").

Note: There is a program to plot controller response curves bundled with the Bmad software
 called "controller_function_plot". Documentation on this can
be found at:
  util_programs/controller_function_plot

###section RF_bend

An "rf_bend" is an RF cavity with the geometry of an "sbend" . This element is
currently considered to be experimental so please contact a Bmad maintainer if you want to use this
type of element.

General "rfcavity" attributes are:
\tt
  \sl Attribute Class      Section            \sl Attribute Class      Section             
  Aperture limits            \refs:limit      Offsets, pitches \& tilt   \refs:offset     
  Chamber wall               \refs:wall       Overlapping Fields         \refs:overlap    
  Custom Attributes          \refs:cust.att   Reference energy           \refs:energy      
  Description strings        \refs:alias      Superposition              \refc:super      
  Symplectify                \refs:symp       Field Maps                 \refs:fieldmap   
  Integration settings       \refs:integ      Tracking \& transfer map   \refc:methods    
  Is_on                      \refs:is.on      Wakes                      \refs:wakes      
  Length                     \refs:l                                                        
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "rf_bend" are:
  ! Bend-like attributes:
  angle              = <Real>   ! Design bend angle. Dependent var .
  b_field            = <Real>   ! Design field strength (= P_0 g / q) .
  g                  = <Real>   ! Design bend strength (= 1/rho).
  l                  = <Real>   ! "Length" of bend. See below.
  l_arc              = <Real>   ! Arc length. For "rbend"s only. 
  l_chord            = <Real>   ! Chord length. See.
  l_sagitta                     ! Sagittal length. Dependent param .
  rho                = <Real>   ! Design bend radius. Dependent param .
  roll               = <Real>   ! See \refs:offset.
  field_master       = <T/F>    ! See \refs:field.master.

  ! RF-like attributes:
  rf_frequency    = <Real>    ! Frequency
  harmon          = <Real>    ! Harmonic number
  harmon_master   = <Logic>   ! Is harmon or rf_frequency the dependent var with ref energy changes?
  phi0            = <Real>    ! Cavity phase (rad/2pi).
  phi0_multipass  = <Real>    ! Phase variation with multipass (rad/2pi).

Tracking through an "rf_bend" is limited to Runge Kutta like tracking methods . The
default "tracking_method" is "runge_kutta". Fields must be specified using a grid field map
. The default "field_calc" is "fieldmap" .

The geometry of the "rf_bend" is the same as an "sbend". An "rf_bend" has a sector shape
which is equivalent to "e1" and "e2" being zero for an "sbend". Since the fields are specified
using a grid field map, there are no fringe attributes to set (for any elements where a grid field is
used, it is always assumed that the fringe fields are included as part of the grid field).

###section RFcavity

An "rfcavity" is an RF cavity without acceleration generally used in a storage ring. The main
difference between an "rfcavity" and an "lcavity" is that, unlike an "lcavity", the
reference energy  through an "rfcavity" is constant.

General "rfcavity" attributes are:
\tt
  \sl Attribute Class      Section            \sl Attribute Class      Section             
  Aperture limits            \refs:limit      Offsets, pitches \& tilt   \refs:offset     
  Chamber wall               \refs:wall       Overlapping Fields         \refs:overlap    
  Custom Attributes          \refs:cust.att   Reference energy           \refs:energy      
  Description strings        \refs:alias      RF Couplers                \refs:rf.coupler 
  Field autoscaling          \refs:autoscale  Superposition              \refc:super      
  Fringe Fields              \refs:fringe     Symplectify                \refs:symp       
  Hkick \& Vkick             \refs:kick       Field Maps                 \refs:fieldmap   
  Integration settings       \refs:integ      Tracking \& transfer map   \refc:methods    
  Is_on                      \refs:is.on      Wakes                      \refs:wakes      
  Length                     \refs:l                                                        
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "rfcavity" are:
  rf_frequency    = <Real>    ! Frequency
  harmon          = <Real>    ! Harmonic number
  harmon_master   = <Logic>   ! Is harmon or rf_frequency the dependent var with ref energy changes?
  voltage         = <Real>    ! Cavity voltage
  phi0            = <Real>    ! Cavity phase (rad/2pi).
  phi0_multipass  = <Real>    ! Phase variation with multipass (rad/2pi).
  phi0_autoscale  = <Real>    ! Set by Bmad if autoscaling is turned on (rad/2pi).
  gradient        = <Real>    ! Accelerating gradient (V/m). Dependent attribute .
  longitudinal_mode = <Int>   ! Longitudinal mode. Default is 1. May be 0 or 1.

The integrated energy kick felt by a particle, assuming no phase slippage, is 
  dE = -e_charge * r_q * voltage * sin(2\,\pi * (\phi_\textt - \phi_\REF))
where
  \phi_\REF = phi0 + phi0_multipass + phi0_autoscale
and \phi_t is the part of the phase due to when the particle arrives at the cavity and depends
upon whether "absolute time tracking" or "relative time tracking" is being used as discussed
in.

In the above equation r_q is the relative charge between the reference particle (set by the
"parameter[particle]" parameter in a lattice file) and the particle being tracked through the
cavity. For example, if the reference particle and and the tracked particle are the same, r_q is
unity independent of the type of particle tracked.

The correspondence between the Bmad "phi0" attribute and the "lag" attribute of
\mad is
  phi0 = mad + 0.5

"phi0_multipass" is only to be used to shift the phase with respect to a "multipass" lord. See
. "e_charge" is the magnitude of the charge on an electron
(Table~\reft:constants). Notice that the energy kick is independent of the sign of the charge of
the particle

"phi0_autoscale" and "field_autoscale" are calculated by Bmad's auto-scale module. See
Section~ for more details. Autoscaling can be toggled on/off by using the
"autoscale_phase" and "autoscale_amplitude" toggles.

Note: Zero phase for \phi_\REF corresponds to the stable fixed point above transition.

Note: "Phi0" is not to be confused with the synchronous phase. The synchronous phase is the phase
of the particle as it passes through the cavity with respect to the RF waveform. The synchronous
phase is not something that is set by the User but rather is established by the balance between the
energy gain of the particle as it goes through the cavities in the ring versus the energy lost to
synchrotron radiation. In fact, for a ring with a single cavity, the synchronous phase is independent
of "phi0". Changing "phi0" in such a situation will result in the closed orbit phase space z to
vary in lock step.

If "harmon" is non--zero the "rf_frequency" is calculated by
  rf_frequency = harmon * c_light * beta0 / L_lattice 
where "L_lattice" is the total lattice length and "beta0" is the
velocity of the reference particle at the start of the lattice. After
the lattice has been read in, "rf_frequency" will be the
independent variable .

Couplers  and HOM wakes  can
be modeled. In addition, if a field map is specified
, tracking using an integrator is possible.

If a field map is specified , tracking using an integrator is possible. A field
map is only used for "runge_kutta", "fixed_step_runge_kutta", and "symp_lie_bmad" tracking
. Only the fundamental mode has an analytical formula for the symplectic
tracking. With "cavity_type" set to "standing_wave", the longitudinal mode is set by the
"longitudinal_mode" parameter. The possible values are 0 or 1 and the default setting is 0.

The "cavity_type" is the type of cavity being simulated. Possible
settings are:
  ptc_standard
  standing_wave    ! Default
  traveling_wave
The "cavity_type" switch is ignored if a field map is used.

Example:
  rf1: rfcav, l = 4.5, harmon = 1281, voltage = 5e6

###section Sad_Mult

A "sad_mult" element is equivalent to a SAD\citeb:sad "mult"
element. This element is a combination solenoid, multipole, bend, and
RF cavity.

General "sample" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section          
  an, bn multipoles      \refs:multip    Length                     \refs:l       
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset  
  Chamber wall               \refs:wall      Reference energy           \refs:energy   
  Custom Attributes          \refs:cust.att  Superposition              \refc:super   
  Description strings        \refs:alias     Tracking \& transfer map   \refc:methods  
  Fringe Fields              \refs:fringe                                               
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "sad_mult" element are:
  bs_field        = <Real>    ! Solenoid field. SAD equivalent: BZ.
  ks              = <Real>    ! Solenoid strength. 
  e1, e2          = <Real>    ! Bend face angles.
  eps_step_scale  = <Real>    ! Step size scale. Default = 1. SAD equivalent: EPS.
  fq1, fq2        = <Real>    ! Quadrupole fringe integral. SAD equivalents: F1, F2.
  x_offset_mult   = <Real>    ! Mult component offset. SAD equivalent: DX.
  y_offset_mult   = <Real>    ! Mult component offset. SAD equivalent: DY.
  fringe_type     = <Switch>  ! Type of fringe. SAD equivalent: DISFRIN.
  fringe_at       = <Switch>  ! Where fringe is applied. SAD equivalent: FRINGE.

 angle           = <Real>    ! Bend angle. A settable dependent variable 
 g               = <Real>    ! Bend strength 1/rho
 rf_frequency    = <Real>    ! RF frequency (Hz). SAD equivalent: FREQ.
 harmon          = <Real>    ! Harmonic number. SAD equivalent: HARM.
 phi0            = <Real>    ! Cavity phase. SAD equivalent: PHI.
 rho             = <Real>    ! Bend radius. A settable dependent variable 
 voltage         = <Real>    ! Cavity voltage. SAD equivalent: VOLT.

One difference between SAD and Bmad is that SAD defines the solenoid field by what are essentially
a set of marker elements so that the solenoid field at a SAD "mult" element is not explicitly
declared in the "mult" element definition. Bmad, on the other hand, requires a "sad_mult"
element to explicitly declare the solenoid parameters.

Another difference between SAD and Bmad is that, within a solenoid, the reference trajectory is
aligned with the solenoid axis (and not aligned with the axis of the elements within the solenoid
region).

The SAD "mult" element uses normal "Kn" and skew "KSn" multipole components. The Bmad
"sad_mult" element used normal "an" and skew "bn" multipole components. As can be seen from
the equations in, there is a factor of n! between the two representations.

The "a0" or "b0" multipole moments give a dipole kick (just like a "kicker" element). The
face angles "e1" and "e2" are used with the dipole kick in calculating fringe effects.

The "fq1" and "fq2" parameters are used to specify the quadrupolar "soft" edge fringe. See
 for more details.

The "fringe_at" and "fringe_type" settings determine if the fringe field is used in
tracking. See Sec~ for the translation between these two switches and the "fringe"
and "disfrin" switches of SAD.

The "x_offset_mult" and "y_offset_mult" orients the non-solenoid components of the field while
leaving the solenoid component unshifted.

Unlike other elements, the "ds_step" and "num_steps" attributes  of a
"sad_mult" are dependent attributes  and are not directly settable. Rather these
attributes are calculated using "SAD"'s own algorithm for setting the step size. To vary the
calculated step size for a single "sad_mult" element, the attribute "eps_step_scale" may be
set.  To vary the step size for all "sad_mult" elements, the global parameter
"bmad_com[sad_eps_scale]"  may be set.  The default values for these
parameters are:
  eps_step_scale          = 1
  bmad_com[sad_eps_scale] = 5e-3

SAD conventions to be aware of when comparing SAD to Bmad:
*
A SAD "rotate" or "chi3" rotation is opposite to a Bmad "tilt"
*
SAD element offsets ("dx", "dy", "dz") are with respect to the entrance end of the element
as opposed to Bmad's convention of referencing to the element center.
*
  The Bmad "sad_mult" element does not have any attributes corresponding to the following
SAD "mult" element attributes:
\vspace1.0ex
  angle, harmon, freq, phi, dphi, volt, dvolt
\vspace1.0ex
That is, "sad_mult" elements cannot be used to simulate RF cavities or bends (but a "sad_mult"
can be used to simulate a kicker type element).

Example:
  qs1: sad_mult, l = 0.1, fringe_type = full, b2 = 0.6 / factorial(2)

###section Sample

A "sample" element is used to simulate a material sample which is illuminated by x-rays.

General "sample" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section         
  Aperture limits            \refs:limit     Offsets, pitches \& tilt   \refs:offset   
  Chamber wall               \refs:wall      Reference energy           \refs:energy   
  Custom Attributes          \refs:cust.att  Surface Properties         \refs:surface 
  Description strings        \refs:alias     Superposition              \refc:super   
  Integration settings       \refs:integ     Tracking \& transfer map   \refc:methods 
  Length                     \refs:l                                                    
  
\toffset
See for a full list of element attributes along with a their units.

This element is in development.

Attributes specific to an "solenoid" element are:
  mode       = <Switch> ! Reflection or transmission.
  material   = <type>   ! Type of material.

The "mode" parameter can be set to:
  reflection
  transmission
With "mode" set to "reflection", photons will be back scattered
from the sample surface isotropically. In this case the material
properties will not matter. Additionally, a "patch"
 element will be needed after the "sample" element
to properly reorient the reference orbit.

With "mode" set to "transmission", photons will be transmitted
through the sample. In this case "material" will be used to
determine the attenuation and phase shift of the photons.

Example:
  formula409: sample, x_limit = 10e-3, y_limit = 20e-3, mode = reflection

###section Sextupole

A "sextupole" is a magnetic element with a quadratic field
dependence with transverse offset .

General "sextupole" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section            
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip    
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset    
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap   
  Description strings        \refs:alias     Reference energy           \refs:energy     
  Fringe Fields              \refs:fringe    Superposition              \refc:super     
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp      
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap  
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods    
  Length                     \refs:l                                                       
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "sextupole" element are:
  k2          = <Real>   ! Sextupole strength.
  b2_gradient = <Real>   ! Field strength. .
  field_master = <T/F>    ! See.
The normalized sextupole "k2" strength is related to the unnormalized "b2_gradient" field
strength through \Eqkqlbp.

The "bmad_standard" calculation treats a sextupole using a kick--drift--kick model.

If the "tilt" attribute is present without a value then a value of 
\pi/6 is used.
Example:
  q03w: sext, l = 0.6, k2 = 0.3, tilt  ! same as tilt = pi/6

###section Sol_Quad

A "sol_quad" is a combination solenoid/quadrupole. Alternatively, the "sad_mult" element
can also be used. The advantage of the "sad_mult" element is that it can simulate a
quadrupole field that is canted with respect to the solenoid field.

General "sol_quad" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap    
  Description strings        \refs:alias     Reference energy           \refs:energy      
  Fringe Fields              \refs:fringe    Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp       
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods     
  Length                     \refs:l                                                        
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "sol_quad" element are:
  k1           = <Real>    ! Quadrupole strength.
  ks           = <Real>    ! Solenoid strength.
  bs_field     = <Real>    ! Solenoid Field strength.
  b1_gradient  = <Real>    ! Quadrupole Field strength.
  field_master = <T/F>     ! See.
The normalized quadrupole "k1" and solenoid "ks" field strengths are related to the
unnormalized "b1_gradient" and "bs_field" field strengths through \Eqkqlbp.

Example:
  sq02: sol_quad, l = 2.6, k1 = 0.632, ks = 1.5e-9*parameter[p0c]

###section Solenoid

A "solenoid" is an element with a longitudinal magnetic field.

General "solenoid" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap    
  Description strings        \refs:alias     Reference energy           \refs:energy      
  Fringe Fields              \refs:fringe    Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp       
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods     
  Length                     \refs:l                                                        
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to an "solenoid" element are:
  ks           = <Real>  ! Solenoid strength.
  bs_field     = <Real>  ! Solenoid field strength.
  field_master = <T/F>   ! See.
  l_soft_edge  = <Real>  ! For modeling a "soft" fringe.
  r_solenoid   = <Real>  ! Solenoid radius.

The "ks" and "bs_field" parameters are the normalized and unnormalized solenoid strengths related
through \Eqkqlbp.

The "bmad_standard" tracking model  uses a "hard edge" model where the field
goes from zero to full strength. 
Example:
  cleo_sol: solenoid, l = 2.6, ks = 1.5e-9 * parameter[p0c]

"Soft edge" end fields may be simulated by using Runge-Kutta tracking and setting the
"field_calc" parameter of the element to "soft_edge". Equations for the soft edge model are
taken from Derby and Olbert \citeb:derby. The equations used are for the exact ideal azimuthally
symmetric solenoid model (not the near-axis approximation model). In this case "ks" and
"bs_field" are the field of an infinite pipe with the same current density (equal to
\mu_0\,n\,I in the notation of Derby and Olbert).  Example:
  soft_sol: solenoid, l = 1.0, field_calc = soft_edge, l_soft_edge = 0.5, 
              r_solenoid = 0.1, tracking_method = runge_kutta, mat6_calc_method = tracking
Here the solenoid is modeled as a perfect current carrying cylinder with a length of 0.5~meters and
a cylinder radius of 0.1~meters. The length of the element, 1.0~meters, must be greater than
"l_soft_edge" since particles need to be tracked through the non-zero fringe field that extends
outside of the cylinder. In fact, since the field is always finite everywhere, to the extent that
the field is nonzero at the edges of the element places a bound on the accuracy of the simulation.
Note that "bmad_standard" tracking will always ignore the setting of "field_calc". That is,
with "bmad_standard" tracking the field always extends to the edges of the element and the value
of "l_soft_edge" is ignored.

###section Taylor

A "taylor" is a Taylor map  that maps the input orbital phase space and
possibly spin coordinates of a particle at the entrance end of the element to the output orbital and
spin coordinates at the exit end of the element. This can be used in place of the \mad "matrix"
element.

General "taylor" attributes are:
\tt
  \sl Attribute Class      Section          \sl Attribute Class      Section          
  Aperture limits            \refs:limit    Offsets \& tilt            \refs:offset  
  Custom Attributes          \refs:cust.att Reference energy           \refs:energy  
  Description strings        \refs:alias    Superposition              \refc:super   
  Is_on                      \refs:is.on    Symplectify                \refs:symp    
  Length                     \refs:l        Tracking \& transfer map   \refc:methods 
  
\toffset
See for a full list of element attributes along with a their units.

Attributes specific to a "taylor" element are:
  ref_orbit = (<x>, <px>, <y>, <py>, <z>, <pz>)     ! Reference orbit.
  x_ref  = <Real>                                   ! $x$ reference orbit component.
  px_ref = <Real>                                   ! $p_x$ reference orbit component.
  y_ref  = <Real>                                   ! $y$ reference orbit component.
  py_ref = <Real>                                   ! $p_y$ reference orbit component.
  z_ref  = <Real>                                   ! $z$ reference orbit component.
  pz_ref = <Real>                                   ! $p_z$ reference orbit component.
  {<out>: <coef>, <e1> <e2> <e3> <e4> <e5> <e6>}    ! Taylor term. First form.
  {<out>: <coef> | <n1> <n2> ...}                   ! Taylor term. Second form.
  tt<out><n1><n2>...  = <Coef>                      ! Taylor term. Third form.
  delta_ref_time = <Real>                           ! Change in the reference time.
  delta_e_ref = <Real>                              ! Change in the reference energy.                 

For historical reasons, there are three different forms that can be used to specify a
taylor term.  Notice that the first form (above) uses a comma "," to separate the
"<coef>" from "<e1>", while the second form uses a vertical bar "|" to separate
"<coef>" from "<n1>".

The orbital (x, p_x, y, p_y, z, p_z) part of the Taylor map, \Cal M, maps input orbital coordinates
r(\In) to the output orbital coordinates r(\Out)
  r(\Out) = \calbfM(r(\In))
Notice that Stern-Gerlach effects are ignored so that the output coordinates are independent of the
spin. \calbfM has six components \Cal M_j one for each output coordinate r_j(\Out)
  r_j(\Out) = \CalM_j(r(\In))
Each \CalM_j is made up of a number of terms
  \CalM_j = \sum_k = 1^N_j M_jk
and each term M_jk is a polynomial in the input orbital coordinates with respect to the reference orbit.
  M_jk(r(\In)) = C_jk \cdot \Pi_i = 1^6 \, \delta r_i^e_ijk
where C_jk is the coefficient for the term, the e_ijk are integer exponents, and \delta
r = r(\In) - r_\REF with r_\REF with being the reference orbit.

A term in a Taylor map can be specified by one of three forms as shown above. The first form is
  {<out>: <coef>, <e1> <e2> <e3> <e4> <e5> <e6>}
"<Out>" is an integer in the range 1 to 6 corresponding to the index j in \Eqmcpd ("<out>"
= 1 for x, etc.). "<coef>" corresponds to C_jk in \Eqmcpd, and "<e1>", "<e2>",
"<e3>", "<e4>", "<e5>", and "<e6>" correspond to e_ijk, i = 1 \ldots 6.
For example, the Taylor map 
  p_y(\Out) = 0.9 \cdot \delta x + 2.73 \cdot \delta y^2(\In) \, \delta p_z(\In) + \ldots
would be written as
  {4: 0.9, 1 0 0 0 0 0}, {4: 2.73, 0 0 2 0 0 1}, ...

The second form for specifying a Taylor term uses the syntax:
  {<out>: <coef> | <n1> <n2> ...}
The set of integers "<n1>", "<n2>" each must be between 1 and 6 inclusive. The value of the
i\Th exponent e_ijk in \Eqmcpd is equal to the number of integers that are equal to i. For
example, the above Taylor map would be written using the second form as
  {4: 0.9 | 1}, {4: 2.73 | 336}, ...
Notice that with the second form, spaces between exponent integers is optional.

The third form is like the second form and has the syntax:
  tt<out><n1><n2>...  = <Coef>                      ! Taylor term. Third form.
For example, the Taylor map above would be written using the third form as:
  tt41 = 0.9, tt4336 = 2.73, ...

The spin  part of the transport map \calbfQ  gives the
spin rotation quaternion q  as a function of input orbital coordinates (the form of the
T-BMT equation assures that \calbfQ cannot depend upon the spin coordinates):
  q = \calbfQ(r(\In))
q has four components and in analogy to \Eqrmr2 one writes
  q_j = \CalQ_j(r(\In))
Each \CalQ_j is made up of a number of terms
  \CalQ_j = \sum_k = 1^N_j Q_jk
and each term Q_jk is a polynomial in the input orbital coordinates with respect to the reference orbit.
  Q_jk(r(\In)) = C_jk \cdot \Pi_i = 1^6 \, \delta r_i^e_ijk

Rather than using an integer index, the four components of a quaternion are labeled ("S1",
"Sx", "Sy", "Sz"). The syntax for the spin part uses the three forms as
described above. For example
  {Sx: 0.43 | 13 }          ! or
  {Sx: 0.43, 1 0 1 0 0 0}   ! or
  ttSx13 = 0.43
is equivalent to the term
  S_x = 0.43 \cdot \delta x(\In) \, \delta y(\In)

By default, a "taylor" element starts out with the unit phase space map.  That is, a "taylor"
element starts with the following 6 terms
  {1: 1.0, 1 0 0 0 0 0}, {2: 1.0, 0 1 0 0 0 0},
  {3: 1.0, 0 0 1 0 0 0}, {4: 1.0, 0 0 0 1 0 0}
  {5: 1.0, 0 0 0 0 1 0}, {6: 1.0, 0 0 0 0 0 1}
Which is equivalent to
  {1: 1.0 | 1}, {2: 1.0 | 2}, {3: 1.0 | 3}
  {4: 1.0 | 4}, {5: 1.0 | 5}, {6: 1.0 | 6}

If there are no "Sx" spin terms are present, the "Sx" quaternion component will always
evaluate to zero.  This is equivalent to a single term {Sx: 0.0 |}.  Similarly for the "Sy" and
"Sz" components. If no "S1" term is present, it is considered an error if any "Sx",
"Sy", or "Sz" term is present. If no "S1", "Sx", "Sy", nor "Sz" spin terms are
present, "S1" component will be given a default term of {S1: 1.0 |}. Thus, if no spin terms are
present at all, the spin map will be the unit map.

The "ref_orbit" attribute specifies the phase space (x, px, y, py, z, pz) reference
orbit at the start of the element used to construct the Taylor map. Alternatively, the
individual components of the reference orbit may be specified by using the attributes 
"x_ref", "px_ref", "y_ref", "py_ref", "z_ref", or "pz_ref".

Note: when converting the map from Bmad to PTC , the Bmad/PTC interface
code will convert from Bmad phase space coordinates to PTC phase space coordinates and
will convert the map to using the reference orbit as the map zero orbit. This does not
affect tracking but will affect map analysis.

A term in a "taylor" element will override any previous term
with the same "out" and "e1" through "e6" indexes. For example the term:
  my_tlr: Taylor, {1: 4.5, 1 0 0 0 0 0} 
will override the default "{1: 1.0, 1 0 0 0 0 0\" term.

The "l" length attribute of a "taylor" element does not affect phase space coordinates but
will affect the longitudinal s position of succeeding elements and will affect the time it takes a
particle to track through the element The calculation involves first calculating the change in
reference time which is the time a particle with the reference energy would take to transverse the
element. Next, \Eqzbctt is used with the change in the phase space z coordinate to calculate
the time a particle takes to traverse the element.

The time a particle takes to track through a "taylor" element can also be controlled by setting
the "delta_ref_time" attribute which sets the travel time for the reference
particle. "delta_ref_time" is a dependent attribute so that if both "l" and
"delta_ref_time" are set, the value of "delta_ref_time" will be modified by Bmad to
correspond to the setting of "l".

The "delta_e_ref" attribute can be used to modify the reference energy at the exit end of the
"taylor" element. The phase space transport is completely determined by the Taylor map and is
independent of "delta_e_ref". For example, with a unit Taylor map, the phase space coordinates
p_x and p_y constant through the element independent of "delta_e_ref". However, a finite
"delta_e_ref" will modify the reference momentum P_0 and hence through \Eqppp will affect the
transport downstream of the "Taylor" element. This behavior is in contrast to how
"delta_e_ref" is handled in a "patch" element. In a "patch" element, the transformation
used when "delta_e_ref" is non-zero is to hold as constant the actual transverse momenta P_x
and P_y and then p_x and p_y are modified using \Eqppp.

A "taylor" element that is "turned off" ("is_on" attribute set to False), is
considered to be like a "marker" element. That is, the orbit and Twiss parameters are
unchanged when tracking through a "taylor" element that is turned off.

Example "taylor" element definitions:
  mtlr: Taylor, {4:  2.7, 0 0 2 0 0 1}, {2:  1.9 | 1 1 2},
              {S1: 0.43 | 2 }, ..., 
              ref_orbit = (0.01, 0.003, 0.002, 0.001, 0.0, 0.2)
  t_unit: taylor {s1: 1 | }  ! This is the identity spin/orbital map.
And 

Note: When tracking a particle's spin through a map, the quaternion used to rotate the spin is
always normalized to one so that the magnitude of the spin will be invariant. 

Note: Tracking through a "taylor" elements using "symp_lie_ptc" is the same as
tracking with the "taylor" tracking method.  That is, the Taylor map is simply
evaluated and no effort at symplectification is done. Furthermore, evaluating the Taylor
map of a "taylor" element using the "taylor" method is faster than evaluation using
"symp_lie_ptc". Thus the "taylor" tracking method should always be used with
"taylor" elements.

###section Thick_Multipole

A "thick_multipole" element is like a "sextupole" or "octupole" element except that the
"thick_multipole" does not have a "K2" sextupole like parameter nor a "K3" octupole like
parameter. Rather, "thick_multipoles", like "sextupole" or "octupole" elements, have
"a0", "a1", "a2", etc.  and "b0", "b1", "b2", etc. multipoles
. In terms of tracking, given equivalent multipole values, "thick_multipoles"
are indistinguishable from "sextupoles" or "octupoles".  "thick_multipole" elements are
useful for differentiating elements that only have higher order multipole moments.

General "thick_multipole" attributes are:
\tt
  \sl Attribute Class      Section             \sl Attribute Class      Section             
  Aperture limits            \refs:limit       Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall        Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att    Overlapping Fields         \refs:overlap    
  Description strings        \refs:alias       Reference energy           \refs:energy      
  Fringe Fields              \refs:fringe      Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick        Symplectify                \refs:symp       
  Integration settings       \refs:integ       Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on       Tracking \& transfer map   \refc:methods     
  Length                     \refs:l                                                         
  
\toffset
See for a full list of element attributes along with a their units.

Example:
  tm1: thick_multipole, l = 4.5, tilt, x_pitch = 0.34, a7 = 1.23e3, b8 = 7.54e5

###section Wiggler and Undulator 

A "wiggler" or "undulator" element is basically a periodic array of alternating bends.
The difference between "wigglers" and "undulators" is in the x-ray emission spectrum.
Charged particle tracking will be the same. 

Henceforth, the term ""wiggler"" will denote either a "wiggler" or "undulator"

General "wiggler" attributes are:
\tt
  \sl Attribute Class      Section           \sl Attribute Class      Section             
  Aperture limits            \refs:limit     Mag \& Elec multipoles     \refs:multip     
  Chamber wall               \refs:wall      Offsets, pitches \& tilt   \refs:offset     
  Custom Attributes          \refs:cust.att  Overlapping Fields         \refs:overlap    
  Description strings        \refs:alias     Reference energy           \refs:energy      
  Fringe Fields              \refs:fringe    Superposition              \refc:super      
  Hkick \& Vkick             \refs:kick      Symplectify                \refs:symp       
  Integration settings       \refs:integ     Field Maps                 \refs:fieldmap   
  Is_on                      \refs:is.on     Tracking \& transfer map   \refc:methods     
  Length                     \refs:l                                                        
  
\toffset
See for a full list of element attributes along with a their units.

There are three types of wigglers. Wigglers that are described using a magnetic field map are called
""map type"" and are discussed in. Wigglers that are described
assuming a periodic field are called ""periodic type"" and are described in
. The third type of wiggler has a custom field. The different wiggler types
are distinguished by the setting of the element's "field_calc" parameter as discussed in
section~. For example:
  wig1: wiggler, l = 1.6, field_calc = fieldmap, ...
In this example "wig1" is a map type wiggler. 

Attributes specific to wiggler and undulator elements are: 
  b_max      = <Real>  ! Maximum magnetic field (in T) on the wiggler centerline.
  l_period   = <Real>  ! Length over which field vector returns to the same orientation.
  n_period   = <Real>  ! The number of periods. Dependent attribute .
  l_pole     = <Real>  ! Wiggler pole length. DEPRECATED. USE L_PERIOD INSTEAD.
  n_pole     = <Real>  ! The number of poles. DEPRECATED. USE N_PERIOD INSTEAD.
  polarity   = <Real>  ! For scaling the field.
  kx         = <Real>  ! Planar wiggler horizontal wave number.
  k1x                  ! Planar wiggler horizontal defocusing strength. Dep attribute .
  k1y                  ! Planar wiggler vertical focusing strength. Dep attribute .
  g_max                ! Maximum bending strength. Dependent attribute.
  osc_amplitude        ! Amplitude of the particle oscillations. Dependent attribute.

The "polarity" value is used to scale the magnetic field. By
default, "polarity" has a value of 1.0.  Example:
  wig1: wiggler, l = 1.6, polarity = -1, cartesian_map = {...}
In this example the wiggler field is defined by a Cartesian map  and the field is
reversed from what it would be with "polarity" set to 1.

###subsection Periodic Type Wigglers

"Periodic type" wigglers are modeled assuming the field is periodic longitudinally. "Periodic
type" wigglers have their "field_calc" parameter set to one of
  planar_model    ! Default
  helical_model
For historic purposes, if there is no fieldmap defined for the element (that is, it is not a "map
type" wiggler), and "field_calc" is not set, then \vnfield_calc" will default to \vnplanar_model".

Example:
  wig2: wiggler, l = 1.6, b_max = 2.1, n_period = 8
This defines a periodic type wiggler with "field_type" defaulting to \vnplanar_model".

For the "planar_model", wigglers use a simplified model where the wiggler has field components
  B_x=            -\textb_max" \, \frack_x"k_y" \, \sin(k_x \, x) \, \sinh(k_y \, y) \, \cos(k_z \, z + \phi_z)  \CRNO
  B_y= \hphantom-\textb_max \,                    \cos(k_x \, x) \, \cosh(k_y \, y) \, \cos(k_z \, z + \phi_z) 
  B_z=            -\textb_max \, \frack_zk_y \, \cos(k_x \, x) \, \sinh(k_y \, y) \, \sin(k_z \, z + \phi_z) \nonumber
with k_y^2 = k_x^2 + k_z^2. Here z is the distance from the beginning of the wiggler, the input
parameter "b_max" is the maximum field on the centerline, and k_z is given in terms of the
period length ("l_period") by
  k_z = \frac2\pil_\textperiod
The phase \phi_z is chosen so that B_y is symmetric about the center of the wiggler
  \phi_z = \frac-k_z \, L2
Note: Originally k_z was calculated using "l_pole" --- the length of a pole --- with the period
length being twice the pole length. When the helical model option was introduced this became
problematical since the period of a helical wiggler could be either 2 or 4 times the pole length
depending upon the geometry. As a result, using the pole length was deprecated and instead the
period length or number should be used.

The "helical_model" for the field is
  B_x=            -\textb_max \, \cosh(k_z \, x) \, \sin(k_z \, z + \phi_z)  
  B_y= \hphantom-\textb_max \, \cosh(k_z \, y) \, \cos(k_z \, z + \phi_z) \CRNO
  B_z=            -\textb_max \, \left[ \sinh(k_z \, x) \, \cos(k_z \, z + \phi_z) +
                                            \sinh(k_z \, y) \, \sin(k_z \, z + \phi_z) \right] \nonumber

With "field_calc" set to "planar_model", and with "bmad_standard" tracking
, the horizontal and vertical focusing is assumed small. The vertical motion is
modeled as a combination focusing quadrupole and focusing octupole giving a kick (modified from \citeb:corbett)
  \fracdp_ydz = k_1y \left( y + \frac23 \, k_y^2 \, y^3 \right)
where
  g_\textmax= \frace \, B_\maxP_0 \, (1 + p_z) 
  k_1y= \frac-k_y^22 \, k_z^2 \, g_\textmax^2 
with "k1y" (a dependent element attribute) being the linear focusing constant. 

The averaged horizontal motion is
  \fracdp_xdz = k_1x \, x
with
  k_1x = \frack_x^22 \, k_z^2 \, g_\textmax^2 

With "field_calc" set to "helical_model", and with "bmad_standard" tracking, the transport
in the vertical and horizontal planes is the same as with the transport in the vertical plane with
"planar_model" (\Eqpyzk1).

While "bmad_standard" tracking uses an averaged trajectory, the actual trajectory has oscillations 
that look like
  x = A \, \cos (k_z \, z)
with the amplitude A given by
  A = \fracg_\textmaxk_z^2
The value of A, computed for an on-energy (p_z = 0) particle, is calculated and stored in the
dependent parameter "osc_amplitude".

With "field_calc" set to "planar_model" and "bmad_standard" tracking, the phase \phi_z in
\Eqspkl2 is irrelevant. When the tracking involves Taylor maps and symplectic integration, the
choice of phase is such that, with an integer number of periods, a particle that enters the wiggler
on-axis will leave the wiggler on-axis provided there is an integer number of periods. Notice that with
"field_calc" set to "helical_model" it is not possible to set the phase so that a particle
that enters the wiggler on-axis will leave the wiggler on-axis. 

When using a tracking through a periodic wiggler with a tracking method that integrates through the
magnetic field , The magnetic field is approximated using a single wiggler "term"
as if the wiggler were a "map type" wiggler. This wiggler model has unphysical end effects and
will give results that are different from the results obtained when using the "bmad_standard"
tracking method.

Tracking a particle through a wiggler is always done so that if the particle starts on-axis with no
momentum offsets, there is no change in the z coordinate even though the actual trajectory through
the wiggler does not follow the straight line reference trajectory.

###subsection Map Type Wigglers

"Map type" wigglers are modeled using a field map as described in section~.
"Map type" wigglers have their "field_calc" parameter set to "fieldmap". Note: For historic
reasons, unlike other types of elements, "field_calc" will default to "fieldmap" if there is a
field map present in a "wiggler".

Unlike "periodic type" wigglers, the "b_max" attribute for a "map type" "wiggler" 
is a dependent attribute and is 
set by Bmad to be the maximum field on-axis computed for "polarity" = 1.

Note: There is no "bmad_standard" tracking for a "map_type" "wiggler". 

###subsection Old Wiggler Cartesian Map Syntax

When the wiggler model was first developed, the only type of map that could be used for "map
type" wigglers was a Cartesian map (\srefs:fieldmap"). The syntax for specifying this Cartesian
map was different from what it is currently. The old syntax for a Cartesian map term was:
  \textterm(i) = {C, k_x, k_y, k_z, \phi_z }
Example:
  wig1: wiggler, l = 1.6, 
        term(1) = {0.03, 3.00, 4.00, 5.00, 0.63},
        term(2) = ...

The old syntax was limited to using the "cartesian_map" "y" family 
with x_0 = y_0 = 0. There was also a different normalization convention. The old style
"hyper-y" form was
  B_x= -& C \,\dfrack_xk_y \sin(k_x x) \sinh(k_y y) \cos(\kzz)\CRNEG
  B_y=  C \,                 \cos(k_x x) \cosh(k_y y) \cos(\kzz)\qquad \text! Old style \CRNEG
  B_s= -& C \,\dfrack_zk_y \cos(k_x x) \sinh(k_y y) \sin(\kzz)\labelf1 
  \makebox[1pt][l]with k_y^2 = k_x^2 + k_z^2 .&&&  \nonumber
The old style "hyper-xy" form was
  B_x=  C \,\dfrack_xk_y \sinh(k_x x) \sinh(k_y y) \cos(\kzz)\CRNEG
  B_y=  C \,                 \cosh(k_x x) \cosh(k_y y) \cos(\kzz)\qquad \text! Old style \CRNEG
  B_s= -& C \,\dfrack_zk_y \cosh(k_x x) \sinh(k_y y) \sin(\kzz)\labelf2 
  \makebox[1pt][l]with k_y^2 = k_z^2 - k_x^2 ,&&&  \nonumber
The old style "hyper_x" form was
  B_x=  C \,\dfrack_xk_y \sinh(k_x x) \sin(k_y y) \cos(\kzz)\CRNEG
  B_y=  C \,                 \cosh(k_x x) \cos(k_y y) \cos(\kzz)\qquad \text! Old style \CRNEG
  B_s= -& C \,\dfrack_zk_y \cosh(k_x x) \sin(k_y y) \sin(\kzz)\labelf3 
  \makebox[1pt][l]with k_y^2 = k_x^2 - k_z^2 .&&& \nonumber
The correspondence between C in the above equations and A in the new equations is
given by comparing \Eqsf1, \eqf2, and \eqf3 with \Eqsfamily.y.

When the cartesian_map construct was being developed, an intermediate hybrid syntax was used defined:
  term(i) = {A, k_x, k_y, k_z, x_0, y_0, \phi_z, \textfamily}
The parameters here directly correspond to the "cartesian_map" forms (see \Eqscm1 through \eqbsq).

For example, the old style syntax:
  term(1) = {0.03*4/5, 3.00, 4.00, 5.00, 0.63 }    ! Old style
is equivalent to the hybrid syntax:
  term(2) = {0.03, 3.00, 4.00, 5.00, 0, 0, 0.63, y}  ! Hybrid style

Note: When converting from the old or hybrid styles to the new syntax, the "field_calc" parameter
must be set to "fieldmap".

