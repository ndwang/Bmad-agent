###chapter Tracking of Charged Particles

Bmad can track both charged particles and X-rays. This chapter deals with charged particles and
X-rays are handled in chapter~.

For tracking and transfer map calculations (here generically called "tracking"), Bmad has various
methods that can be applied to a given element (Cf. Chapter~). This chapter
discusses the "bmad_standard" calculation that is the default for almost all element types and
the "symp_lie_bmad" calculation that does symplectic integration.

Generally, it will be assumed that tracking is in the forward direction.

###section Relative Versus Absolute Time Tracking

Unlike other elements, the kick given a particle going through an "lcavity", "rfcavity", or
possibly an "em_field" element depends upon the time that the particle enters the element
relative to some "RF clock". Bmad has two modes for calculating this time called ""relative
time tracking"" and ""absolute time tracking"". The switch to set the type of tracking for a
lattice is "bmad_com[absolute_time_tracking]" (\srefs:bmad.common").\footnote
  
An old, deprecated notation for this switch is "parameter[absolute_time_tracking]".
  "
The phase of the RF, \phi_\textrf, is determined by
  \phi_\textrf = \phi_\textt + \phi_\REF
where \phi_\textt is the part of the phase that depends upon the time t and \phi_\REF
is a fixed phase offset (generally set in the lattice file) and independent of the particle
coordinates. See \Eqslcav.phi and \eqrfcav.phi

The phase \phi_\textt is 
  \phi_\textt = f_\textrf \ t_\texteff
where f_\textrf is the RF frequency, and t_\texteff is the effective time. With "relative
time tracking", which Bmad uses by default, t_\texteff" is a function of the 
phase space coordinate z  via
  t_\texteff(s) = t_0(s) - t_0(s_\textent) - \fracz(s)\beta \, c
where t_0 is the reference time (see \Eqzbctt) and s_\textent is the s-position at the
upstream end of the element. t_\texteff is defined such that a particle entering an element 
with z = 0 has t_\texteff = 0.

With "absolute time tracking", and "bmad_com[absolute_time_ref_shift]" set to True (the
default), t_\texteff is defined by
  t_\texteff(s) = t(s) - t_0(s_\textent)
t_0(s_\textent), by definition, equal to the time of the reference particle at the entrance end
of the element. With multipass, t_0(s_\textent) is set by the time of the
reference particle at the entrance end of the element on the first pass. For absolute time tracking,
it is important to keep in mind that t_0(s_\textent) is a property of the element independent of
how tracking is done. Thus, if a particle goes through a particular element multiple times, the
value of t_\textent will be the same for each transit. If "bmad_com[absolute_time_ref_shift]"
set to True, t_\texteff is simply
  t_\texteff(s) = t(s) 

To understand the difference between relative and absolute time tracking, consider a particle
traveling on the reference orbit along side the reference particle in a circular ring with one RF
cavity. This particle always has z = 0 and thus, with "relative time tracking", t_\texteff
will always be zero (assuming "bmad_com[absolute_time_ref_shift]" is set to True) at the entrance
to the cavity.  With "absolute time tracking", the particle, on the first turn, will have
t_\texteff equal to zero. However, on subsequent turns (or subsequent passes if using
multipass), the time will increase by the revolution time t_\textC on each turn. If the RF
frequency f_\textrf is some multiple of the revolution harmonic, the RF phase with absolute vs
relative time tracking will be some multiple of 2 \, \pi and thus RF kick given the particle will
be the same in both cases. However, if the RF frequency is not some multiple of the revolution
harmonic, there will be a difference in the RF kicks (except for the kick on the first turn).

There are advantages and disadvantages to using either relative or absolute time tracking. Absolute
time tracking is more correct since RF cavities may have frequencies that are not commensurate with
the revolution time. The problem with absolute time tracking is that the transfer map through the
cavity is now a function of time and therefore is a function of z \em and the turn number. This
complicates lattice analysis. For example, standard element transfer maps use phase space
coordinates so with absolute time tracking, one has a different map for each turn.

With relative time tracking the transfer map problem is swept under the rug. The penalty for using
relative time tracking is that results can be unphysical. For example, with relative time tracking,
the closed orbit is essentially independent of the RF frequency. From a different angle this can be
viewed as a desirable feature since if one is only interested in, say, calculating the Twiss
parameters, it can be an annoyance to have to worry that the ring one has constructed have a length
that is exactly commensurate with the RF frequency. And it is potentially confusing to see non-zero
closed orbits when one is not expecting it due to a mismatch between the ring circumference and the
RF frequency or due to RF cavities not being spaced a multiple of the RF wavelength apart.

The above discussion is limited to the cavity fundamental mode. Long-range wakefields, on the
other hand, cannot be synchronized to the z coordinate since, in general, their frequencies are
not commensurate with the fundamental mode frequency. For simulating the long-range wakes, the kick
is thus, by necessity, tied to the absolute time. The exception is that a wake associated with the
fundamental mode (that is, has the same frequency as the fundamental mode) will always use relative
time if the fundamental is using relative time and vice versa.

Do not confuse absolute time tracking with the "time_runge_kutta" tracking method
. The "time_runge_kutta" method uses time as the independent variable instead of
z. Absolute time tracking just means that the RF phase is dependent upon the time instead of
z. It is perfectly possible to use absolute time tracking with code that uses z as the
independent variable.

One important point to always keep in mind is that any PTC based tracking  will
always use relative time tracking independent of the setting of "bmad_com[absolute_time_tracking]".

###section Element Coordinate System

The general procedure for tracking through an element makes use of "element reference"
coordinates (also called just "element" coordinates). Without any offsets, pitches or tilt
, henceforth called "misalignments", the "element" coordinates are the same as
the "laboratory reference" coordinates (or simply "laboratory" coordinates)
. The "element" coordinates stay fixed relative to the element. Therefore, if the
element is misaligned, the "element coordinates" will follow as the element shifts in the
laboratory frame as shown in \figf:ele.coord.

Tracking a particle through an element is a three step process:
*
At the entrance end of the element, transform from the "laboratory" coordinates to the entrance
"element" coordinates.
*
Track through the element ignoring any misalignments. 
*
At the exit end of the element, transform from the exit "element" reference frame to the
"laboratory" reference frame.

The transformation between "laboratory" and "element" reference frames is given in
 and.

  \includegraphics[width=5in]coord-offset.pdf
  
"Element" coordinates are coordinates attached to the physical element (solid green outline). The
"laboratory" coordinates are fixed at the nominal position of the element (red dashed outline).
  
###section Hamiltonian
The time dependent Hamiltonian H_t in the curvilinear coordinate system shown
in \figf:local.coords is (\citeb:ruth)
  H_t = \wt\psi + \left[ \left( \fracp_s - a_s1 + g\, x \right)^2 + \wt m^2 + 
  (p_x - a_x)^2 + (p_y - a_y)^2 \right]^1/2
where (p_x, p_y, p_s/(1+gx)) are the momentum normalized by P_0, \rho being the local radius
of curvature of the reference particle, and \wt m, a and \wt\psi are the normalized mass,
vector, and scalar potentials:
  \wt m = \fracm \, c^2c \, P_0 \qquad
  \left( a_x, a_y, \fraca_s1+g \, x \right) = \fracq \, AP_0 \, c \qquad 
  \wt\psi(x,y,z) = \fracq \, \psiP_0
In terms of the normalized velocities \beta_x, \beta_y, the canonical momentum are
  p_x = \fracm \, c^2P_0 \, c \, \gamma \, \beta_x + a_x, \qquad 
  p_y = \fracm \, c^2P_0 \, c \, \gamma \, \beta_y + a_y

The s-dependent Hamiltonian is obtained from H_t by solving for
-p_s and using a contact transformation to convert to Bmad
coordinates . For particles propagating in the
positive s direction, the s-dependent Hamiltonian is, assuming
\wt\psi is zero
  H \equiv H_s = -(1 + g \, x) \sqrt(1 + p_z)^2 - (p_x - a_x)^2 - (p_y - a_y)^2 - 
  a_s + \frac1\beta_0 \, \sqrt(1+p_z)^2 + \wt m^2
where \beta_0 is the reference velocity and the equality (1 +
p_z)^2 = (E/c\, P_0)^2 - \wt m^2 has been used. The last term on the
RHS of \Eqh1gx1 accounts for the fact that the Bmad canonical z
(\Eqzbctt) has an "extra" term \beta \, c \, t_0 so that Bmad
canonical z is with respect to the reference particle's z.

The equations of motion are
  \fracdq_ids = \frac\partial H\partial p_i \qquad
  \fracdp_ids = -\frac\partial H\partial q_i

non-curved coordinate system (g = 0), and using the paraxial approximation (which
expands the square root in the Hamiltonian assuming the transverse momenta are small)
, \Eqh1gx1 becomes
  H = \frac(p_x - a_x)^22 (1 + p_z) + \frac(p_y - a_y)^22 (1 + p_z) - 
  (1 + p_z) - a_s +   \frac1\beta_0 \, \sqrt(1+p_z)^2 + \wt m^2

Once the transverse trajectory has been calculated, the longitudinal position
z_2 at the exit end of an element is obtained from symplectic
integration of \Eqhpapa
  z_2 = z_1 - \frac12 (1 + p_z1)^2 \int \! ds \, 
  \left[ (p_x - a_x)^2 + (p_y - a_y)^2 \right] - \int \! ds \, g \, x
where z_1 is the longitudinal position at the entrance end of the element.
Using the equations of motion \Eqsrshp this can also be rewritten as
  z_2 = z_1 - \frac12 \int \! ds \, 
  \left[ \left( \fracdxds \right)^2 + \left( \fracdyds \right)^2 \right] - 
  \int \! ds \, g \, x

For some elements, "bmad_standard" uses a truncated Taylor map for
tracking.  For elements without electric fields where the particle
energy is a constant, the transfer map for a given coordinate r_i
may be expanded in a Taylor series
  r_i,2 \rightarrow m_i + \sum_j = 1^4 m_ij \, r_j,1 + 
  \sum_j = 1^4 \sum_k = j^4 m_ijk \, r_j,1 \, r_k,1 + \ldots
where the map coefficients m_ij\cdots are functions of p_z.  For
linear elements, the transfer map is linear for the transverse
coordinates and quadratic for r_i = z.

Assuming mid--plane symmetry of the magnetic field, so
that a_x and a_y can be set to zero\citeb:madphysics, The vector
potential up to second order is (cf.~\Eqbyx0b)
  a_s = -k_0 \left( x - \fracg \, x^22 (1 + g\, x) \right) -
  \frac12 k_1 \left( x^2 - y^2 \right)

For backwards propagation, where particle are traveling in the -\f
s direction and where p_s is negative, solving for p_s involves
using a different part of the square root branch. There is also an
overall negative sign coming from switching from using s as the
independent variable to \wt s \equiv -s as the independent
variable. the Hamiltonian H_\wt s is then
  H_\wt s = -(1 + g \, x) \sqrt(1 + p_z)^2 - (p_x - a_x)^2 - (p_y - a_y)^2 + 
  a_s + \frac1\beta_0 \, \sqrt(1+p_z)^2 + \wt m^2

###section Symplectic Integration

Using \Eqhpapa the Hamiltonian is written in the form
  H = H_x + H_y + H_z
where
  H_x = \frac(p_x - a_x)^22 (1 + \delta), \qquad
  H_y = \frac(p_y - a_y)^22 (1 + \delta), \qquad
  H_s = - a_s 

For tracking, the element is broken up into a number of slices set by
the element's "ds_step" attribute. For each slice, the tracking
uses a quadratic symplectic integrator I:
  I = T_s/2 \; I_x/2 \; I_y/2 \; I_s \; I_y/2 \; I_x/2 \; T_s/2
T_s/2 is just a translation of the s variable:
  s \rightarrow s + \fracds2
And the other integrator components are
  I_x/2= \exp \left( : -\fracds2 H_x : \right) \CRNO
  I_y/2= \exp \left( : -\fracds2 H_y : \right) 
  I_s  = \exp \left( : -ds \, H_s : \right) \nonumber
The evaluation of I_x/2 and I_y/2 is tricky since it involves both transverse
position and momentum variables. The trick is to split the integration into three parts.
For I_x/2 this is
  I_x/2= \exp \left( : -\fracds2 \frac(p_x - A_x)^22 (1 + \delta) : \right) \CRNO
 = \exp \left( : -\int A_x \, dx : \right) \,
     \exp \left( : -\fracds2 \fracp_x^22 (1 + \delta) : \right) \,
     \exp \left( : \int A_x \, dx : \right)
With an analogous expression for I_y/2.

For magnetic elements that do not have longitudinal fields
(quadrupoles, sextupoles, etc.), a_x and a_y can be taken to be
zero (cf.~\Eqakxgx).

For "lcavity" and "rfcavity" elements, the vector potential is computed from
\Eqaiew.

###section BeamBeam Tracking

A beam-beam element  simulates the effect on a tracked particle of an opposing
beam of particles moving in the opposite direction. The opposing beam, called the "strong" beam,
is assumed to be Gaussian in shape.

The strong beam is divided up into "n_slice" equal charge (not equal thickness) slices.
Propagation through the strong beam involves a kick at the charge center of each slice with drifts
in between the kicks. The kicks are calculated using the standard Bassetti--Erskine complex error
function formula\citeb:talman.  Even though the strong beam can have a finite "sig_z", the
length of the element is always considered to be zero. This is achieved by adding drifts at either
end of any tracking so that the longitudinal starting point and ending point are identical. The
longitudinal s--position of the "BeamBeam" element is at the center of the strong bunch. For
example, with "n_slice" = 2 and with a solenoid field, the calculation would proceed as follows:
  * 
Start with the particle longitudinally at the "beambeam" element (which is considered to have
zero longitudinal length) in laboratory coordinates .
  %
  *
Propagate backwards through the solenoid field so that the particle is in the plane of the first
beambeam slice. The fact that the plane of the slice may be, due to finite "x_pitch" or
"y_pitch" values, canted with respect to the laboratory x-y plane is taken into account.
  %
  *
Transform the particle coordinates to the "beambeam" element body coordinates
.
  %
  *
Apply the beam--beam kick due to the first slice including a spin rotation.
  %
  *
Transform back to laboratory coordinates.
  %
  *
Propagate forwards so that the particle is in the plane of the second slice.
  %
  *
Transform the particle coordinates to the "beambeam" element body coordinates.
  %
  * 
Apply the beam--beam kick due to the second slice.
  %
  * 
Transform back to laboratory coordinates.
  %
  * 
Propagate backwards through the solenoid field to end up with the particle longitudinally at the
"beambeam" element.
  %

There is an energy kick due to the motion of the strong beam. There are two parts to this dp_z =
dp_z,s + dp_z,h. One part, dp_z,s, is similar to the gravitational slingshot in orbital
mechanics. The slingshot energy kick is simply calculated using conservation of 4-momentum of the
tracked particle and the strong beam where the mass of the strong beam is assumed to be large
compared to the mass of the tracked particle.\footnote
  
This assumption breaks down if a tracked particle is deflected due to a single scattering event with
a particle of the strong beam.  But particle-particle scattering is outside of the assumption of a
strong beam that is unaffected by the weak beam.
  
After a little bit of algebra. The energy kick dE_w to lowest order in the angle of the weak
particle with respect to the axis defined by the of motion of the strong beam is
  dE_w = \fracc \, P_w2 \, (1/\beta_w + 1/\beta_s) \, \left( \theta_w2^2 - \theta_w1^2 \right)
where P_w is the momentum of the weak particle, \beta_w and \beta_s are the weak and strong
beam velocities, and \theta_w1 and \theta_w2 are angles of the weak particle trajectory with
respect to the strong beam motion before and after the interaction. Converting to phase space
coordinates, the momentum kick dp_z is
  dp_z,s = \frac12 \, \beta_w \, (1/\beta_w + 1/\beta_s) \, (1 + p_z) 
    \left( dp_x \, (dp_x + 2p_x1) + dp_y \, (dp_y + 2p_y1) \right)
where dp_x and dp_y are the transverse kicks and p_x1 and p_y1 are the initial phase
space momenta.

The other part of the energy kick, dp_z,h, happens when the strong beam's cross-section is changing due to
the hourglass effect. The hourglass longitudinal kick relative to the transverse kicks can derived using
Eq.~(5) of Sagan \citeb:beamion. In the relativistic limit the result is
  dp_z,h = \frac\sigma_x2 \, \fracd\sigma_xds \, \fracdp_xdx + 
             \frac\sigma_y2 \, \fracd\sigma_yds \, \fracdp_ydy
where \sigma_x and \sigma_y are the strong beam sizes, and the factor of two is due to the
relative velocity (2c) between the beams.

\newpage  % If newpage is removed, the footnote get put on the next page! 

###section Bend: Exact Body Tracking with k1 = 0

  \includegraphics[width=5in]bend-exact.pdf

Function definitions:
  \sinc(x)\equiv \frac\sin(x)x 
  \cosc(x)\equiv \frac1 - \cos(x)x^2
These functions cannot be directly evaluated at x = 0 and are defined at x = 0 using the x
\rightarrow 0 limit. The point to keep in mind here is that these functions are well behaved and
can be easily coded in software.

Referring to Figure~\reff:bend.exact, at point 1 where the particle enters a sector bend, the angle
\phi_1 of the particle trajectory in the (x,s) plane with respect to the s axis is
  \sin(\phi_1) = \fracp_x1\sqrt(1+p_z)^2 - p_y^2
where the subscript "1" for p_z and p_y is dropped since these quantities are invariant.

The (u,v) coordinate system in the plane of the bend is defined with the u-axis along the exit
edge of the bend and the v-axis is perpendicular to the u-axis. The origin is at the design
center of the bend. In this coordinate system the point (u_1, v_1) where the particle enters the
bend is given by
  u_1= (\rho + x_1) \, \cos(\theta) 
  v_1= (\rho + x_1) \, \sin(\theta)
where \rho is the design radius of curvature, x_1 is the offset of the particle from the design
at the entrance point, and \theta is the design bend angle
  \theta = \fracL\rho = g \, L
with L being the design arc length and g \equiv 1/\rho.

The coordinates (u_0, v_0) of the center of curvature of the particle trajectory is
  u_0= u_1 - \rho_p \, \cos(\theta + \phi_1) 
  v_0= v_1 - \rho_p \, \sin(\theta + \phi_1)
where \rho_p is the radius of curvature of the particle trajectory in the (u, v) plane (see
\Eqg1rg).

The coordinates of the particle at the exit face is (u_2, 0) where
  u_2 = u_0 + \sqrt\rho_p^2 - v_0^2
After some manipulation, the offset of the particle x_2 from the design point at the exit face is
  x_2 = u_2 - \rho = x_1 \, \cos(\theta) - L^2 \, g \, \cosc(\theta) + \xi
where \xi can be expressed in two different ways
  \xi= \frac\alpha\left[ \cos^2(\theta + \phi_1) + g_p \, \alpha \right]^1/2 + \cos(\theta + \phi_1) 
    \quad \textor \labelxctlg1 
 = \frac\left[ \cos^2(\theta + \phi_1) + g_p \, \alpha \right]^1/2 - \cos(\theta + \phi_1)g_p
where
  \alpha= 2 \, (1 + g \, x_1) \, \sin(\theta + \phi_1) \, L \, \sinc(\theta) - 
        g_p \, (1 + g \, x_1)^2 \, L^2 \, \sinc^2(\theta) 
  g_p= \frac1\rho_p = \fracg_\tot\sqrt(1 + p_z)^2 - p_y^2 \labelg1rg
In the above equation g_\tot is the bending strength of the actual field. Both \Eqxctlg1 and
\Eqxctlg2 are needed since \Eqxctlg1 is singular when \alpha = 0 and \theta + \phi_1 = \pi
(which happens when the particle is bent by 180\Deg), and \Eqxctlg2 is singular when g_p is
zero. A simple way to implement the calculation for x_2 is to use \Eqxctlg1 when |\theta +
\phi_1| < \pi/2 and otherwise use \Eqxctlg2.

Once x_2 is computed, the arc length of the particle L_p is 
  L_p = \frac|L_c|\sinc(\theta_p/2)
where L_c is the vector (chord) from point 1 and point 2
  L_c = (L_cu, L_cv) =
  \left( \xi, -L \, \sinc(\theta) - x_1 \, \sin(\theta) \right) 
and \theta_p is the angle made by the particle trajectory which is twice the angle between
the initial particle trajectory P and the vector L_c
  \theta_p = 2 \, \left( \theta + \phi_1 - \atantwo \left( L_cu, -L_cv \right) \right)
where \atantwo(y, x) is the standard two argument arctangent function.

Once L_p is computed, p_x2, y_2 and z_2 are easily derived from
  p_x2= \sqrt(1 + p_z)^2 - p_y^2 \, \sin(\theta + \phi_1 - \theta_p) 
  y_2= y_1 + \fracp_y \, L_p\sqrt(1+p_z)^2 - p_y^2 
  z_2= z_1 + \frac\beta \, L\beta_\REF - \frac(1 + p_z) \, L_p\sqrt(1+p_z)^2 - p_y^2
where \beta is the normalized velocity of the particle and \beta_\REF if the normalized
velocity of the reference particle.

Using the above equation, round-off error will give a non-zero final position even if the initial
position is zero. Even though the round-off error will be very small, a non-zero result can be
confusing. To avoid this, the standard linear transfer matrix for a bend is used if all the
following conditions are satisfied:
  |x \, g|, |p_x|, |p_y|, |p_z| <  10^-9, \quad \textand, \quad g_\tot = g
The matrix is:
    \cos(\theta)            L \, \sinc(\theta)  0 0 0 g \, L^2 \, \cosc(\theta) 
   -g \, \sin(\theta)       \cos(\theta)        0 0 0 g \, L \, \sinc(\theta)   
    0                       0                   1 L 0 0                         
    0                       0                   0 1 0 0                         
   -g \, L \, \sinc(\theta) 
                       -g \, L^2 \, \cosc(\theta) 0 0 1 
                   L \,  \left( \frac1\gamma^2 - g^2 \, L^2 \, \sincc(\theta) \right) 
    0                       0                   0 0 0 1                       
where
  \sincc(\theta) \equiv \fracx - \sin(x)x^3

###section Bend: Body Tracking with finite k1

For a bend with a finite "k1", the Hamiltonian for the body of an "sbend" is
  H = (g_\tot - g) \, x - g \, x \, p_z + 
  \frac12\left( (k_1 + g \, g_\tot) x^2 - k_1 \, y^2 \right) +
  \fracp_x^2 + p_y^22 (1 + p_z) 

This is simply solved
  x_2   = c_x \, (x - x_c) + s_x \, \fracp_x11 + p_z1 + x_c \CRNO
  p_x2= \tau_x \, \om_x^2 \, \, (1 + p_z1) \, s_x \, (x -x_c) + c_x \, p_x1 \CRNO
  y_2   = c_y \, y_1 + s_y \, \fracp_y11 + p_z1 \CRNO
  p_y2= \tau_y \, \om_y^2 \, \, (1 + p_z1) \, s_y \, y_1 + c_y \, p_y1 
  z_2   = z_1 + m_5 + m_51 (x - x_c) + m_52 p_x1 + m_511 \, (x-x_c)^2 \, + \CRNO
                       m_512 \, (x-x_c) \, p_x1 + m_522 \, p_x1^2 + 
                         m_533 \, y^2 + m_534 \, y_1 \, p_y1 + m_544 \, p_y1^2 \CRNO
  p_z2= p_z1 \nonumber
where 
  k_x= k_1 + g \, g_\tot \qqquad
  \om_x\equiv \sqrt\frac|k_x|1 + p_z1 \CRNO
  x_c= \fracg \, (1 + p_z1) - g_\totk_x \qqquad
  \om_y\equiv \sqrt\frac|k_1|1 + p_z1 
and
                      k_x > 0                      k_x < 0 \qqquad
                      k_1 > 0                      k_1 < 0 \CRNO
     c_x=  \cos  (\om_x \, L)              \cosh (\om_x \, L) \qqquad
     c_y=  \cosh (\om_y \, L)              \cos  (\om_y \, L) \CRNO
     s_x=  \frac\sin  (\om_x \, L)\om_x& \frac\sinh (\om_x \, L)\om_x \qqquad
     s_y=  \frac\sinh (\om_y \, L)\om_y& \frac\sin  (\om_y \, L)\om_y 
  \tau_x=  -1            +1             \qqquad
  \tau_y=  +1            -1             \nonumber
and
  m_5    = -g \, x_c \, L \qqquad \CRNO
  m_51 = -g \, s_x \qqquad
  m_52 = \frac\tau_x \, g1 + p_z1 \, \frac1 - c_x\om_x^2 \CRNO
  m_511= \frac\tau_x \,\, \om_x^24 \, (L - c_x \, s_x) \qqquad
  m_533= \frac\tau_y \,\, \om_y^24 \, (L - c_y \, s_y) \CRNO
  m_512= \frac-\tau_x \,\, \om_x^22 \, (1 + p_z1) \, s_x^2 \qqquad
  m_534= \frac-\tau_y \,\, \om_y^22 \, (1 + p_z1) \, s_y^2 \CRNO
  m_522= \frac-14 \, (1 + p_z1)^2 \, (L + c_x \, s_x) \qqquad
  m_544= \frac-14 \, (1 + p_z1)^2 \, (L + c_y \, s_y) \nonumber

###section Bend: Fiducial Point Calculations

When the "fiducial_pt" switch for a bend is set to something other than "none", changing one
of "rho", "g", "b_field" or "angle" in a program (that is, changing after the lattice
has been read in and the bend parameters calculated) involves adjustment to the other three
parameters along with adjustment to "e1", "e2", "l", "l_chord", and
"l_rectangle". This is done to keep the shape of the bend invariant. Invariance is not maintained
with variation of any other parameter (EG variation of "e1").

    \includegraphicsbend-vary1.pdf
With "fiducial_pt" set to "entrance_end", r_1 is the fiducial point at the entrance
end.  By construction, the entrance point r_1 and the
slope of the reference curve at r_1 is invariant with the reference curve before (dashed line)
and after (solid line) being tangent to s_1 where s_1 being the perpendicular to x_1.
    
    \includegraphicsbend-vary2.pdf
With "fiducial_pt" set to "center", r_c is the fiducial point at the center. By
construction, the reference curve always goes through r_c and the tangent of the reference
curve at r_c is invariant.
  
Geometry with "fiducial_pt" set to (a) "entrance_end" and (b) "center". In both cases,
r_1 and r_2 are the entrance and exit reference points before and r'_1 and r_2
are the entrance and exit points after variation of one of "rho", "g", "b_field", or
"angle".  Similarly, \rho and \alpha are the bending radius and bending angle before
variation while \rho' and \alpha' are the bending radius afterwards.  Finally, e_1 e_2
are the face angles and rectangular length before variation, and L'_r and r'_0 are the
rectangular length and center of curvature after variation.
  
\figf:bend.fid shows the situation when the "fiducial_pt" is set to either "entrance_end" or
"center" (the situation for the "exit_end" setting is analogous to the "entrance_end"
setting and so is not discussed). For any one of the "fiducial_pt" settings discussed there are
essentially two cases. One case is direct variation of the bend field via variation of "rho",
"g", or "b_field". This is called ""g"-variation". The other type of variation is
variation of "angle". This is called "angle-variation". The discussion below shows how, with
"g"-variation, "l", "e1", and "e2" are calculated. With "angle"-variation, "l",
"g", "e1", and "e2" need to be calculated. Once "l" and "g" are know, the other
parameters "l_chord", "l_rectangle", "l_sagitta" (and "angle" for the "g"-variation
case) can be readily computed.

The "entrance_end" analysis is as follows (\figf:bend.fid1). The entrance end coordinates
around the point r_1 are held fixed and as as a result r'_1 = r_1 and "e1" does not
vary as well. r_2 is the exit point before variation and r_3 is the exit point after. The
position of r_3 is calculated by first calculating the position of r_1 in a coordinate
system centered at r_2 and with axes parallel to the (s_1, x_1) axes of the coordinate
system at r_1
  \barr_1 = \left( -l_\textrectangle, \rho \, (1 - \cos\alpha) \right)
Where the bar denotes that the coordinates are in the (s_1, x_1) system.
The coordinates of r_1 in the (e_s, e_x) coordinate system
with origin at r_2 and with e_x along the bend edge and e_s perpendicular to e_x
is a rotation R(\theta) 
  r_1 = R(\alpha - e_2) \, \barr_1
The angle \theta_1 of the vector s_1, which is the invariant tangent of the reference curve
at the point r_1, in the (e_s, e_x) coordinate system (which is used from here on) is
  \theta_1 = \alpha - e_1
The center of curvature after variation r'_0 is 
  r'_0 = r_1 + \rho' \, \left( \sin\theta_1, -\cos\theta_1 \right)
The reference trajectory after variation r' is a circular arc subject to the condition
  \left| r' - r'_0 \right| = \rho'^2
With "g"-variation, the value of \rho' is set (perhaps indirectly) by the User. To find the
point r'_2, it is noted that in the (e_s, e_x) coordinate system,  the s
coordinate of r'_2, r'_2s is zero.
so using this in\Eqrr0r and throwing away the unphysical root gives for the x coordinate
  r'_2x = r_1x + \frac2 \, c-b - \sqrtb^2-4 \, a \, c
where
  a= g' \CRNO
  b= 2 \, \cos\theta_1 
  c= g' \, r_1s^2 + 2 \, r_1s \, \sin\theta_1 \nonumber
where g' = 1 / \rho'.
The rectangular length after variation L'_r is then
  L'_r = L_r + r'_2x * \sin\theta_1
where L_r is the rectangular length before variation.
Finally, the length L' after variation is
  L' = \textasinc \left( g' \, L'_r \right) \, L'_r
where \textasinc is the function
  \textasinc(\theta) = \frac\sin^-1(\theta)\theta

For "fiducial_pt" set to "entrance_end" and with "angle"-variation, \alpha' is know and
g' can be computed via
  g' = \frac\sin(\alpha' - \theta_1) + \sin(\theta_1)r_1s
With this, all other parameters can be created. In both "angle"-variation and "g"-variation the new
face angle e'_2 is given by
  e'_2 = e_2 + \alpha' - \alpha

For "fiducial_pt" set to "center", The center point r_c (see \figf:bend.fid2) is held
constant.  Here the "g"-variation analysis is similar to the "g"-variation analysis with
"fiducial_pt" set to "entrance_end" (or "exit_end" except in this case the reference orbit
to the right and left of bfr_c are analyzed separately and the two lengths for each piece are
added together. For "angle"-variation, the only situation where it is possible to keep r_c
fixed while varying the angle is when "e1" and "e2" are equal. In this instance, the
calculation is again similar to the "angle"-variation analysis with the "fiducial_pt" set to
either end. If "e1" and "e2" are not equal, a calculation is done that gives the desired angle
but the center point will shift.

###section Converter Tracking

Tracking through a "converter" element involves generating five random numbers
  \footnote
Since the outgoing particle starts at the exit surface of the converter only five numbers
are needed to generate the 6-dimensional particle phase space position.
  
and then using these numbers with the outgoing particle distribution to generate the position and
orientation of the outgoing particle. The outgoing particle distribution is pre-computed by a
program "converter_element_modeling" and the distribution parameters are included in the
converter element description in the Bmad lattice file . The accuracy of the
converter modeling will depend in part upon the granularity of the probability tables generated
by the "converter_element_modeling" program and on other approximations made during
tracking. Generally, inaccuracies in the 1% to 10% range are to be expected.

In a tracking simulation, a single outgoing particle is generated for each incoming particle. Since,
in a real machine, the number of outgoing particles will not be equal to the number of incoming
particles, each outgoing particle is assigned a weight such that the weighted distribution of
outgoing particles is correct. This weight will be the same for all outgoing particles. The weight
will depend upon whether the momentum or angular range of the outgoing particles is restricted using
the element parameters :
  pc_out_min    ! Minimum momentum of generated outgoing particles (eV).
  pc_out_max    ! Maximum momentum of generated outgoing particles (eV).
  angle_out_max ! Maximum angle to the surface perpendicular (rad).

  \includegraphics[width=5in]converter.pdf
  
An incoming particle strikes the bottom of the converter. At some point within the interior, a new
particle is generated and this new particle exits the top surface. To calculate the position and
orientation of the outgoing particle, a coordinate system is established where the origin point
\wt\calO is the point that the incoming particle would strike the top surface if it went straight
through and the (x,y) axes are randomly rotated with respect to the (x_b,y_b) body coordinate axes.
By construction, the position of the outgoing particle will be along the x-axis.
  
The geometry of the converter is shown in \figf:converter. On the top surface, where the outgoing
particle emerges, (x_b,y_b) are the axes for the element body coordinate system .
To generate the position and orientation of the outgoing particle, another coordinate system is used
with axes labeled by (x,y). Each outgoing particle will be assigned its own (x,y)
axes. The origin \wt\calO of this coordinate system is constructed by placing \wt\calO at the
point where the incoming particle under consideration would strike the top surface if the incoming
particle would pass straight through the converter. The angular orientation of the (x,y) axes
with respect to the (x,y) axes is chosen using a random number with a uniform probability
distribution in the interval [0, \pi]. By construction, the outgoing particle, at the surface of
the converter will be generated at a point a distance r along the x-axis.

The particle distribution is calculated at a number of converter thickness t_i, i = 1 \ldots
N_t. It is an error if the actual converter thickness is outside the range of these
thicknesses. [The exception is if only one distribution for a given thickness is present, this
distribution is used to generate the outgoing particle coordinates independent of the converter
thickness.]  The particle distribution is also calculated within a certain incoming particle
momentum range. It is also an error if an incoming particle has a momentum outside of this range.

The first step is to choose the value of the outgoing particle's momentum p_\txtout. For each
thickness t_i, the pre-computed particle distribution parameters includes a two-dimensional table
of P(p_\txtout, r) --- the probability density of creating an outgoing particle versus
p_\txtout and r. P(p_\txtout,r) is normalized so that the integrated probability is equal
to the average number of outgoing particles created for each incoming particle N_\txtout/N_in
  \fracN_\txtoutN_in = \int \int dp_\txtout \, dr \, P(p_\txtout, r)
The integrals are done using linear interpolation between grid points.  From a P(p_\txtout,r)
probability table, a "normalized" probability P_\txtn(p_\txtout,r) table is computed where
P_\txtn is the probability of generating a particle at given p_\txtout and r with an
angular range restricted by "angle_out_max". If "angle_out_max" is not set, P_\txtn will
be equal to P.  This calculation is part of a "setup" computation done before tracking which, to
save time, is only done if one of the three element parameters, "pc_out_min", "pc_out_max", or
"angle_out_max", changes. Additionally, the setup includes creating a table of I(p_\txtout)
which is the integrated probability for generating a particle with momentum less than p_\txtout
  I_p(p_\txtout) = \frac\dstyle \int_p_\txtmin^p_\txtout d\pw_\txtout 
  \int dr \, P_\txtn(\pw_\txtout, r)
  \dstyle \int_p_\txtmin^p_\txtmax d\pw_\txtout \int dr \, P_n(\pw_\txtout, r)
where p_\txtmin is the minimum momentum in the P(p_\txtout, r) table or the value of
"pc_out_min" which ever is greatest and p_\txtmax is the maximum momentum in the
P(p_\txtout, r) table or the value of "pc_out_max" which ever is smallest. I(p_\txtout)
is normalized such that I(p_\txtmax) = 1. A value for p_\txtout is generated by solving
numerically for p_\txtout the equation
  I_p(p_\txtout) = R_1
where R_1 is a random number with uniform distribution in the interval [0,1].  This
calculation is done for the two t_i thicknesses that straddle the actual thickness. The value of
p_\txtout assigned to the outgoing particle is obtained via linear interpolation between the two
computed values. Note that for both thicknesses the same random number needs to be used.

The next step is to choose a value for r. This is done by solving the equation
  I_r(r) = R_2
where R_2 is another random number with uniform distribution in the interval [0,1] and I_r is 
  I_r(r) = \frac\dstyle \int_0^r d\rw \, P_\txtn(p_\txtout, \rw)
  \dstyle \int_0^r_\txtmax d\rw \, P_n(p_\txtout, \rw)
with p_\txtout being the momentum chosen for the particle and r_\txtmax being the maximum
radius the probability table goes out to\footnote
  
The range [0,r_\txtmax] encompasses nearly all of the outgoing particles. In principle, the
integral could be extended by extrapolating the values in the table but this could potentially lead
to inaccuracies in determining the outgoing orientation. Generally the inaccuracy in truncating the
distribution at r_\txtmax should be small.
  . 
Like p_\txtout, this calculation is done for the two
t_i thicknesses that straddle the actual thickness. The value of r assigned to the outgoing
particle is obtained via linear interpolation between the two computed values. Note that for both
thicknesses the same random number needs to be used.

Once p_\txtout and r have been chosen, the next steps are to choose values for the angular
orientation of the outgoing particle. The angular orientation is characterized by the distribution
parameters using the derivatives x' = dx/ds and y' = dy/ds in the form of a skewed Lorentzian
probability distribution P_d
  P_d\left( x', y' ; p_\txtout, r \right) =
  A_d \, \frac1 + \beta \, x'1 + \alpha_x^2 \, \left( x' - c_x \right)^2 +
  \alpha_y^2 \, \left( y' \right)^2
where the parameters A_d, \beta, c_x, \alpha_x, and \alpha_y all depend upon p_\txtout
and r. Notice that by construction, with the outgoing particle generated on the x-axis, the
distribution is symmetric about y'-axis. The pre-computed distribution characterizes each of these
parameters by a set of one or more fits which are functions of p_\txtout and r. There are also
four functions of p_\txtout and r that give the range over which \Eqpxsxs is valid
x'_\txtmin, x'_\txtmax, y'_\txtmin, and y'_\txtmax. By symmetry, y'_\txtmin =
-y'_\txtmax. Also A_d can be computed from knowledge of \beta, c_x, \alpha_x, and
\alpha_y using the normalization condition that at any given p_\txtout and r
  1 = \int_x'_\txtmin^x'_\txtmax dx' 
  \int_-y'_\txtmax^y'_\txtmax dy' \, P_d \left( x', y' \right)
Thus there are only seven independent parameters that need to be fitted. The fit functions for all
seven have the same form. The fit is divided into two regions. For p_\txtout lower than some
cutoff, a parameter is fit using a set of one-dimensional functions \Gamma_i(r) at discrete momentum p_i,
i = 1, \ldots, N_\beta with
  \Gamma_i(r) = \sum_n=1^M c_n,i \, r^n
The polynomial cutoff M is 4 for c_x and \beta and is 3 for the other five.  To evaluate a
parameter at momenta lower than p_N_\beta, the \Gamma_i are used with linear interpolation in
p between functions of different p_i. At higher energies, the parameter variation is smoother so
a two dimensional fit Xi is used
  \Xi(p_\txtout,r) = e^-(k_p \, p_\txtout + k_r \, r) \,
  \left( \sum_n=0^3 k_n \, r^n \right) \, 
  \left( 1 + \sum_n=1^3 w_n \, p_\txtout^n \right) + C
The C parameter is only nonzero for x'_\txtmin. 

Once A_d, \beta, c_x, \alpha_x, and \alpha_y have been calculated for a given p_\txtout and
r, The calculation of x' starts with integrating P_d in \Eqpxsxs over y'
  I_xd (x')\equiv \int_-y'_\txtlim^y'_\txtlim dy' \, P_d(x', y')
 = 2 \, A_d \, \frac1 + \beta \, x'\alpha_y \, \sqrt1 + \alpha_x^2 \, (x' - c_x)^2  \,
  \tan^-1 \left( \frac\alpha_y \, y'_\txtlim\sqrt1 + \alpha_x^2 \, (x' - c_x)^2 \right)
  \nonumber
where y'_\txtlim is either the lesser of y'_\txtmax and \tan^-1(\textangle_out_max).
A spline fit is used to integrate I_xd and this is used to choose a value for x'. Once x'
is known, The integral of P_d(x', y') over y' is used to choose a value for y'.

Except for the placement of \wt\calO, the above algorithm for calculating the position and
orientation of the outgoing particle will be independent of the angular orientation of the incoming
particle. This is valid for incoming particles that are traveling perpendicular to the converter
surface. To the extent that the incoming particles are not perpendicular to the converter, this will
introduce inaccuracies. Typically, however, the incoming particles will be fairly close to being
perpendicular. Considering this, and considering the approximations used to calculate the
distribution parameters, the neglect of incoming particle orientation effects is usually justified.

###section Drift Tracking

Bmad uses the exact map for a drift
This gives the map
  x_2   = x_1 + \fracL \, p_x1p_l \CRNO
  p_x2= p_x1  \CRNO
  y_2   = y_1 + \fracL \, p_y1p_l \CRNO
  p_y2= p_y1  
  z_2   = z_1 + \left( \frac\beta\beta_\REF - \frac1 + p_z1p_l \right) \, L \CRNO
  p_z2= p_z1 \nonumber
where \beta is the normalized particle velocity, \beta_\REF is the reference particle's
normalized velocity, and p_l is the normalized longitudinal momentum 
  p_l \equiv \fracP_lP_0 = \sqrt(1 + p_z)^2 - p_x^2 - p_y^2
with P_l being the longitudinal momentum.

###section ElSeparator Tracking

  \includegraphics[width=5in]elseparator.pdf
  
Elseparator Electric field. The fringe field lines break the
translational invariance in x.
  
[Thanks to \'Etienne Forest for the derivation of the elseparator equation of motion.]

The Hamiltonian for an electric separator is 
  H = -p_s 
  = - \left{ \left( \frac1\beta_0 + \delta + k_E \, x \right)^2 - 
  \wt m^2 - p_x^2 - p_y^2 \right}^1/2
Here the canonical coordinates (-c \, t, \delta are being used, \wt m is defined in \Eqmmccp,
and p_s = -H is just the longitudinal momentum.  In the above equation, k_E is the normalized
field
  k_E = \fracq \, EP_0 \, c
The field is taken to be pointing along the x-axis with positive k_E accelerating a particle in
the positive x direction. To solve the equations of motion, a "hard edge" model is used where
k_E is constant inside the separator and the field ends abruptly at the separator edges.

Since, as shown in \figf:elsep, the fringe fields break the translational invariance in x, it is
important here that the x = 0 plane be centered within the separator plates. With this, the
canonical momentum \delta just outside the separator assumes its free space form of \delta = (E -
E_0) / E_0). This is analogous to the case of a "solenoid" where, to ensure that the canonical
transverse momenta assume their free space form just outside the solenoid, the z-axis must be
along the centerline of the solenoid.

The solution of the equations of motion is:
  x  = (x_0 - x_c) \, \cosh \left( \frack_E \, Lp_s \right) + 
         \fracp_x0k_E \, \sinh \left( \frack_E \, Lp_s \right) + x_c \CRNO
  p_x= k_E \, (x_0 - x_c) \, \sinh \left( \frack_E \, Lp_s \right) + 
         p_x0 \, \cosh \left( \frack_E \, Lp_s \right) \CRNO
  y  = y_0 + L \, \fracp_y0p_s \labelxxlp 
  p_y= p_y0 \CRNO
  c \, \delta t=  \int_0^L -\frac\partial H\partial \delta
      = (x_0 - x_c) \, \sinh \left( \frack_E \, Lp_s \right) +
        \fracp_x0k_E \, \left[ \cosh \left( \frack_E \, Lp_s \right) - 1 \right]
        \nonumber
where the critical position x_c is
  x_c = -\frac\wt Ek_E
and 
  \wt E \equiv \frac1\beta_0 + \delta = \fracEP_0 \, c
 
\Eqsxxlp predict that for x < x_c and p_x0 = 0 a particle will, unphysically, accelerate in
the negative x direction. In actuality, a particle in this instance will be reflected backwards by
the longitudinal component of the edge field. Specifically, the argument of the square root in
\Eqhp1b must be non-negative and a particle will only make it through the separator if
  x_0 > \frac1k_E \, \left( \sqrt\wt m^2 + p_x0^2 + p_y0^2 - \wt E \right)

###section Foil Tracking

A particle going through a "foil" element is scattered both in angle and in energy, and the
charge of the particle may be affected. The following two subsections give the formulas used for
scattering and energy loss. Currently, the final charge is a fixed number but that may change in the
future.

###subsection Scattering in a Foil

For the angle scattering, the user can select between one of two algorithms, both
of which are given in the paper by Peralta and Louro\citeb:peralta (also see Lynch and Dahl\citeb:lynch)
Both methods vary the phase space p_x and p_y coordinates using:
  (dp_x, dp_y) = \fracp \, \sigmaP_0 \, (r_1, r_2)
where p is the
particle momentum, P_0 is the reference momentum, r_1 and r_2 are Gaussian random numbers with
unit sigma and zero mean, and \sigma is the sigma of the angular scattering distribution. The
factor of p/P_0 is due to a translation between change in angle and change in phase space momenta
(see \Eqxpa1p). 

The "Highland" algorithm uses Eq.~(32) of Peralta and Louro\citeb:peralta to calculate the
scattering sigma:
  \sigma = \frac(13.6 \cdot 10^6~eV) \, zp \, c \, \beta \sqrt\fracXX_0 \, \left[
  1 + 0.038 \, \ln \left( \fracX \, z^2X_0 \, \beta^2 \right) \right]
where X_0 is the material radiation "length" in kg/m^2, z is the particle charge, \beta is the particle
relativistic beta, c is the speed of light, and X is the foil area density in kg/m^2 equal
to \rho \, t where \rho is the material density and t is the foil thickness.

The "Lynch_Dahl" algorithm uses Eq.~(33) of Peralta and Louro:
  \sigma^2 = \frac\chi_c^21 + F^2 \left[ \frac1 + \nu\nu \ln (1 + \nu) - 1 \right]
where
  \nu= \frac0.5 \, \Omega(1 - F) \CRNO
  \Omega= \frac\chi_c^21.167 \, \chi_\alpha^2 \CRNO
  \chi_c^2= \left( 1.57 \cdot 10^10 \, \fraceV^2 \, m^2kg \right) \, 
    \fracZ (Z+1) XA \left[ \fraczp \, \beta \right]^2 
  \chi_\alpha= (2.007 \cdot 10^7 \, eV^2) \, \fracZ^2/3(p \, c)^2 
            \left[1 + 3.34 \,  \left( \fracZ \, z \, \alpha\beta \right)^2 \right] \nonumber
and the A is the atomic weight, p is the particle momentum, \alpha is the fine structure
constant, and F is a fit parameter representing the percent of the central angular distribution
that is used.  F is a settable parameter with a default value of 0.98.

For compound materials, the value of X/X_0 in \Eqsszpb is computed from
  \fracXX_0 = \sum_i = 1^N \fracX_iX_0i
where the summation is over all constituents in the material.

Also for compound materials, \chi_c^2 in \Eqssc1f and \eqno1f is replaced by the sum of the
constituent \chi_ci^2, and \chi_\alpha is computed from Lynch and Dahl Eq.~(11)
  \ln ( \chi_\alpha ) = \left. \sum_i=1^N \fracZ_i (Z_i + 1) X_iA_i \ln(\chi_\alpha i) \middle/
  \sum_i=1^N \fracZ_i (Z_i + 1) X_iA_i \right.

The actual scattering distribution has 1/\theta^4 tails (\theta is the scattering angle) due to
single event large angle scattering (Rutherford scattering). By assuming a Gaussian distribution,
these tails are not present in a simulation. It is also important to note that with both the
"Highland" and "Lynch_Dahl" algorithms, simulating the passage of particles through a single
foil versus two foils with half the thickness as the single foil will not give exactly the same
results. This is just a reflection that both algorithms are trying to model an inherently non-Gaussian
process.

###subsection Energy Loss in a Foil

The particle energy loss per unit length dE/dx through a foil is calculated using the "Bethe-Bloch" formula
  - \left\langle\fracdEdx\right\rangle = 
  \frac4 \pim_e c^2 \cdot \fracnz^2\beta^2 \cdot \left(\frace^24\pi\varepsilon_0\right)^2 \cdot 
  \left[\ln \left(\frac2m_e c^2 \beta^2I \cdot (1-\beta^2)\right) - \beta^2\right]
where n is the material electron density, I is the mean excitation energy, z is the particle
charge, c is the speed of light, \epsilon_0 is the vacuum permittivity, \beta = v/c, is
the normalized velocity, and e and m_e the electron charge and rest mass respectively.

Note that to keep the direction of travel of the particle constant when energy is lost, this implies
that p_x/(1+p_z) and p_y/(1+p_z) are to be held constant (\Eqxpa1p).

###section Kicker, Hkicker, and Vkicker Tracking

The Hamiltonian for a horizontally deflecting kicker or separator is
  H = \fracp_x^2 + p_y^22 (1 + p_z) - k_0 \, x 
This gives the map
  x_2= x_1 + \frac11 + p_z1 \, \left( L \, p_x1 + \frac12 k_0 \, L^2 \right),
    p_x2= p_x1 + k_0 \, L, \CRNO
  y_2= y_1 + \fracL \, p_y11 + p_z1,
    p_y2= p_y1,  
  z_2= z_1 - \fracL2 (1 + p_z1)^2 \, 
    \left( p_x1^2 + p_y1^2 + p_x1 \, k_0 \, L + \frac13 k_0^2 \, L^2 \right), \quad
  p_z2= p_z1 \nonumber
The generalization when the kick is not in the horizontal plane is easily derived.

###section LCavity Tracking

For tracking using something like "runge_kutta", with "field_calc" set to "bmad_standard",
the fields are modeled by the equations given in Sections~ and.

For "bmad_standard" tracking, and with "cavity_type" set to "standing_wave", the transverse
trajectory through an "Lcavity" is modeled using equations developed by Rosenzweig and
Serafini\citeb:rosenzweig (R\&S) with
  b_0 = 1, \qquad \textand \qquad b_-1 = 1 
and all other b_n set to zero.

The transport equations in R\&S were developed in the ultra-relativistic limit with \beta = 1.  To
extend these equations to lower energies, the transport through the cavity body (R\&S Eq.~(9)) has
been modified to give the correct phase-space area at non ultra-relativistic energies:
    x  
    x'
    \cos(\alpha) 
        \sqrt\frac8\eta(\Delta\phi) \, \frac\, \gamma_1\gamma' \, \cos(\Delta\phi) \, \sin(\alpha) 
    -\sqrt\frac\eta(\Delta\phi)8 \, \frac\gamma'\gamma_2 \, \cos(\Delta\phi) \, \sin(\alpha)
        \frac\gamma_1\gamma_2 \, \cos(\alpha)
  \,
    x  
    x'
The added factor of \sqrt\beta_1/\beta_2 gives the matrix the correct determinant of \beta_1 \,
\gamma_1 / \beta_2 \, \gamma_2. \em While the added factor of \sqrt\beta_1/\beta_2 does
correct the phase space area, the above equation can only be considered as a rough approximation for
simulating particles when \beta is significantly different from 1. Indeed, the only accurate way
to simulate such particles is by integrating through the actual field [Cf.~Runge Kutta tracking
].

The change in z going through a cavity is calculated by first calculating the particle
transit time \Delta t
  c \, \Delta t= \int_s_1^s_2 \!\! ds \,\, \frac1\beta(s) 
    = \int_s_1^s_2 \!\! ds \, \fracE\sqrtE^2 - (mc^2)^2 \CRNO
 = \fracc \, P_2 - c \, P_1G = \fracE_2 + E_1P_2 + P_1 \, \fracLc
where L is the accelerating length and it has been assumed that the accelerating gradient G is
constant through the cavity and retarding due to the particle's finite transverse momentum is
ignored. In this equation \beta = v / c, E is the energy, and P is the momentum. The change in
z is thus
  z_2 = \frac\beta_2\beta_1 \, z_1 - 
  \frac\beta_2 \, Lc \, 
  \left(
  \fracE_2 + E_1P_2 + P_1 - 
  \frac\Ebar_2 + \Ebar_1\Pbar_2 + \Pbar_1
  \right)
where \Pbar and \Ebar are the momentum and energy of the reference particle.

Note that the above transport equations are only symplectic on-axis There are second order terms in
the transverse coordinates that are missing. To obtain a proper symplectic matrix, the
"symplectify" attribute of an "lcavity" element  can be set to True.

###section Octupole Tracking

The Hamiltonian for an upright octupole is
  H = \fracp_x^2 + p_y^22 (1 + p_z) + \frack_324 (x^4 - 6 \, x^2 \, y^2 + y^4)

An octupole is modeled using a kick-drift-kick model.

###section Patch Tracking

  \includegraphics[width=5in]patch.pdf
Standard tracking through a patch element. A particle's starting coordinate at the entrance end of
the patch has, by construction, coordinate z = 0. The particle is drifted, as in a field free
region, between the entrance z = 0 plane and the exit z = 0 plane.

The transformation of the reference coordinates through a "standard" patch (a patch where custom
fields are not used) is given by \Eqsvwlv and \eqwws. At the entrance end of the patch, a
particle's position and momentum in the entrance coordinate system will be
  r= (x, y, 0) \CRNO
  P= (P_x, P_y, P_z) = 
    \left( p_x, p_y, \pm \sqrt(1+p_z)^2 - p_x^2 - p_y^2 \right) \, P_0\textent
where p_x, p_y and p_z are the phase space momenta, and z, which is coordinate z and not
phase space z, is always zero by construction as shown in \figf:patch.track [Also see
\figf:local.coords and the discussion in.] The sign of the longitudinal
momentum P_z is determined by whether the particle is traveling in the positive s or negative
s direction (which will occur when an element is flipped longitudinally).

The transformation between entrance and exit coordinate systems is given by \Eqsrwlr and \eqpps
  r\rightarrow 
    S^-1 \, (r - L_\textoff) \CRNO
  P\rightarrow S^-1 \, P
where L_\textoff is given by \Eqswww

After this transformation, the particle must be propagated by a longitudinal length
-r_z to intersect the r_z = 0 plane of the exit face.
  r\rightarrow (r_x - r_z \, \fracP_xP_z, r_y - r_z \, \fracP_yP_z, 0) \CRNO
  P\rightarrow P

The final r and P can now be used compute the particles
phase space coordinates, along with the time t and the reference time
t_\REF at the exit end.
  x\rightarrow r_x \qquadp_x\rightarrow \fracP_xP_0\textexi \CRNO
  y\rightarrow r_y \qquadp_y\rightarrow \fracP_yP_0\textexi 
  z\rightarrow z + r_z \, \frac|P|P_z + L_0 \, \frac\beta\beta_0 +
    \beta \, \textt_offset \qquad
   p_z\rightarrow \frac(1+p_z) \, P_0\textent - P_0\textexiP_0\textexi \CRNO
  t\rightarrow t - r_z \, \frac|P|P_z \, \beta \qquad
 t_\REF\rightarrow t_\REF + \textt_offset + L_0 \, \frac1\beta_0 \nonumber
where the exit reference momentum P_0\textexi is related to the
entrance reference momentum P_0\textent through
"e_tot_offset".  In the above equation, \beta is the particle
velocity, \beta_0 is the velocity of the reference particle, and
L_0 is the drift length of the reference particle
  L_0 = \frac1S^-1_33 \, \left( 
  S^-1_31 \, \textx_offset + S^-1_32 \, \texty_offset + S^-1_33 \, \textz_offset
  \right)

###section Quadrupole Tracking

The "bmad_standard" calculates the transfer map through an upright
quadrupole and then transforms that map to the laboratory frame.

The Hamiltonian for an upright quadrupole is
  H = \fracp_x^2 + p_y^22 (1 + p_z) + \frack_12 (x^2 - y^2)
This is simply solved
  x_2   = c_x \, x_1 + s_x \, \fracp_x11 + p_z1 \CRNO
  p_x2= \tau_x \, \om^2 \, \, (1 + p_z1) \, s_x \, x_1 + c_x \, p_x1 \CRNO
  y_2   = c_y \, y_1 + s_y \, \fracp_y11 + p_z1 \CRNO
  p_y2= \tau_y \, \om^2 \, \, (1 + p_z1) \, s_y \, y_1 + c_y \, p_y1 
  z_2   = z_1 + m_511 \, x_1^2 + m_512 \, x_1 \, p_x1 + m_522 \, p_x1^2 + 
                   m_533 \, y_1^2 + m_534 \, y_1 \, p_y1 + m_544 \, p_y1^2 \CRNO
  p_z2= p_z1 \nonumber
where 
  \om \equiv \sqrt\frac|k_1|1 + p_z1
and
                      k_1 > 0                      k_1 < 0 \qqquad
                      k_1 > 0                      k_1 < 0 \CRNO
     c_x=  \cos  (\om \, L)& \cosh (\om \, L) \qqquad
     c_y=  \cosh (\om \, L)& \cos  (\om \, L) \CRNO
     s_x=  \frac\sin  (\om \, L)\om& \frac\sinh (\om \, L)\om \qqquad
     s_y=  \frac\sinh (\om \, L)\om& \frac\sin  (\om \, L)\om 
  \tau_x=  -1            +1             \qqquad
  \tau_y=  +1            -1             \nonumber
with this
  m_511= \frac\tau_x \,\, \om^24 \, (L - c_x \, s_x) \qqquad
  m_533= \frac\tau_y \,\, \om^24 \, (L - c_y \, s_y) \CRNO
  m_512= \frac-\tau_x \,\, \om^22 \, (1 + p_z1) \, s_x^2 \qqquad
  m_534= \frac-\tau_y \,\, \om^22 \, (1 + p_z1) \, s_y^2 
  m_522= \frac-14 \, (1 + p_z1)^2 \, (L + c_x \, s_x) \qqquad
  m_544= \frac-14 \, (1 + p_z1)^2 \, (L + c_y \, s_y) \nonumber

###section RFcavity Tracking

For tracking using something like "runge_kutta", with "field_calc" set to "bmad_standard",
the fields are modeled by the equations given in Sections~ and.

With "bmad_standard" tracking, a kick-drift-kick model is used. The kick is a
pure energy kick (see equations in) and the phase of the RF is calculated under the
assumption that the waveform moves at a phase velocity equal to the velocity of the reference
particle.

With "bmad_standard" tracking, the transverse forces due to the RF are ignored. This is generally
a reasonable approximation when the acceleration is small as is standard in rings. "Lcavity"
elements should be used in place of "rfcavity" elements when this is not so.

###section Sad_Mult Tracking

The "hard edge" fringe field kick is taken from Forest\citeb:forest Eqs.~(13.29) and onward.
In the notation of Bmad, and taking into account both normal and skew terms, Eq.~(13.29)
is for the m\th order multipole (what Forest labels n+1)
  f_\pm = \mp \Re \frac(b_m + i \, a_m) \, (x + i \, y)^(m+1)4 \, (m+2) \, (1 + p_z)
    \left[ x \, p_x + y \, p_y + i\fracm+3m+1(x \, p_y - y \, p_x) \right]

The "soft edge" dipole fringe for "sad_mult" elements is a generalization of the soft edge
dipole fringe for a SAD bend element. For the entrance kick the equations are:
  x_2= x_1 + \frac\delta_11 + \delta_1 \, \Delta x_fx, \qquad
  p_x2 = p_x1 + \frac11 + \delta_1 \, \left[ 
    \Delta x_fy \, v - \Delta x_fay \, v^3 \right] \CRNO
  y_2= y_1 - \frac\delta_11 + \delta_1 \, \Delta y_fy, \qquad
  p_y2 = p_y1 + \frac11 + \delta_1 \, \left[ 
    \Delta y_fx \, w - \Delta y_fax \, w^3 \right] 
  z_2= z_1 + \frac1(1 + \delta_1)^2 \, \left[ \, 
    \Delta x_fx \, p_x1 - \Delta y_fy \, p_y1 + 
    \frac12 \, (\Delta y_fx + \Delta x_fy) \, w^2 -
    \frac14 (\Delta y_fax + \Delta x_fay) \, w^4
    \right] \nonumber
where
  \Delta x_fx = \fracK_0 \, F_B^224 \, L, \qquad 
  \Delta y_fx = \fracK_0^2 \, F_B6 \, L^2, \qquad 
  \Delta y_fax= \frac2 \, K_0^23 \, F_B \, L^2, \CRNO 
  \Delta y_fy = \fracSK_0 \, F_B^224 \, L, \qquad
  \Delta x_fy = \fracSK_0^2 \, F_B6 \, L^2, \qquad
  \Delta x_fay= \frac2 \, SK_0^23 \, F_B \, L^2, 
  v= \cos\theta \, x_1 + \sin\theta \, y_1, \qquad
  w= -\sin\theta \, x_1 + \cos\theta \, y_1, \qquad
  \tan\theta= \frac-SK_0K_0 \nonumber

###section Sextupole Tracking

The Hamiltonian for an upright sextupole is
  H = \fracp_x^2 + p_y^22 (1 + p_z) + \frack_26 (x^3 - 3 \, x \, y^2)

Tracking through a sextupole uses a kick-drift-kick model.

###section Sol_Quad Tracking

The Hamiltonian is
  H = \frac(p_x + \frack_s 2\, y)^22 (1 + p_z) + 
  \frac(p_y - \frack_s2 \, x)^22 (1 + p_z) + \frack_12 (x^2 - y^2)
Solving the equations of motion gives
  x_2   = m_11 \, x_1 + m_12 \, p_x1 + m_13 \, y_1 + m_14 \, p_y1 \CRNO
  p_x2= m_21 \, x_1 + m_22 \, p_x1 + m_23 \, y_1 + m_24 \, p_y1 \CRNO
  y_2   = m_31 \, x_1 + m_32 \, p_x1 + m_33 \, y_1 + m_34 \, p_y1 \CRNO
  p_y2= m_41 \, x_1 + m_42 \, p_x1 + m_43 \, y_1 + m_44 \, p_y1 
  z_2   = z_1 + \sum_j = 1^4 \sum_k = j^4 m_5jk \, r_j \, r_k  \CRNO
  p_z2= p_z1 \nonumber
where
  m_11= \frac12 \, f \, \left( f_0+ \, c + f_0- \, c_h \right) \qqquad
  m_31= -m_24 \CRNO
  m_12= \frac12 \, f \, (1 + p_z1) \, 
            \left( \fracf_++\om_+ \,  s + \fracf_--\om_- \, s_h \right) \qqquad
  m_32= -m_14 \CRNO
  m_13= \frac\ks4 \, f \, 
            \left( \fracf_+-\om_+ \, s +\fracf_-+\om_- \, s_h \right) \qqquad
  m_33= \frac12 \, f \, \left( f_0- \, c + f_0+ \, c_h \right) \CRNO
  m_14= \frac\ksf \, (1 + p_z1) \, \left( -c + c_h \right) \qqquad
  m_34= \frac12 \, f \, (1 + p_z1) \, 
            \left( \fracf_+-\om_+ \, s + \fracf_-+\om_- \, s_h \right) \CRNO
  m_21= \frac-(1 + p_z1)8 \, f \, 
            \left( \frac\xi_1+\om_+ \, s + \frac\xi_2+\om_- s_h \right) \qqquad
  m_41= -m_23 
  m_22= m_11 \qqquad
  m_42= -m_13 \CRNO
  m_23= \frac\ks^3 \, (1 + p_z1)4 \, f \, \left( c - c_h \right) \qqquad
  m_43= \frac-(1 + p_z1)8 \, f \, 
            \left( \frac\xi_1-\om_+ \, s + \frac\xi_2-\om_- \, s_h \right) \CRNO
  m_24= \frac\ks4 \, f \, 
            \left( \fracf_++\om_+ \, s + \fracf_--\om_- \, s_h \right) \qqquad
  m_44= m_33 \nonumber
and
  \kone       = \frack_11 + p_z1 \qqquad 
  \ks         = \frack_s1 + p_z1 \CRNO
  f           = \sqrt\ks^4 + 4 \, \kone^2 \qqquad
  f_\pm0    = f \pm \ks^2 \CRNO
  f_0\pm    = f \pm 2 \, \kone \qqquad
  f_\pm\pm  = f \pm \ks^2 \pm 2 \, \kone \CRNO
  \om_+       = \sqrt\fracf_+02 \qqquad
  \om_-       = \sqrt\fracf_-02 
  s           = \sin (\om_+ \, L) \qqquad
  s_h         = \sinh (\om_- \, L) \CRNO
  c           = \cos (\om_+ \, L) \qqquad
  c_h         = \cosh (\om_- \, L) \CRNO
  \xi_1\pm= \ks^2 \, f_+\mp \pm 4 \, \kone \, f_+\pm \qqquad
  \xi_2\pm= \ks^2 \, f_-\pm \pm 4 \, \kone \, f_-\mp \nonumber

The m_5jk terms are obtained via \Eqzz121p
  m_5jk = - \frac\tau_jk2 (1 + p_z1)^2 \int \! ds \, 
  \left[ 
    \left( m_2j + \frack_s2 \, m_3j \right) \, 
    \left( m_2k + \frack_s2 \, m_3k \right)   
  \right. + 
                 \left.
    \left( m_4j - \frack_s2 \, m_1j \right) \, 
    \left( m_4k - \frack_s2 \, m_1k \right) 
  \right] \nonumber
where
  \tau_jk = 
    1 j = k 
    2 j \ne k 
The needed integrals involve the product of two trigonometric or
hyperbolic functions. These integrals are trivial to do but the
explicit equations for m_5jk are quite long and in the interests of
brevity are not reproduced here.

  \includegraphics[width=5in]solenoid.pdf
  
Solenoid with a hard edge. The field is assumed to end abruptly at the edges of the solenoid. Here,
for purposes of illustration, the field lines at the ends are displaced from one another.
  
###section Solenoid Tracking

The "bmad_standard" solenoid tracking does not make the small angle approximation.
The transfer map for the solenoid is:
  x_2   = \frac1 + c2 \, x_1 + \fracsk_s \, p_x1 +
           \fracs2 \, y_1 + \frac1 - ck_s \, p_y1 \CRNO
  p_x2= \frac-k_s \, s4 \, x_1 + \frac1 + c2 \, p_x1 - 
           \frack_s \, (1 - c)4 \, y_1 + \fracs2 \, p_y1 \CRNO
  y_2   = \frac-s2 \, x_1 - \frac1 - ck_s \, p_x1 +
           \frac1 + c2 \, y_1 + \fracsk_s \, p_y1       
  p_y2= \frack_s \, (1 - c)4 \, x_1 + \frac-s2 \, p_x1 -
            \frack_s \, s4 \, y_1 + \frac1 + c2 \, p_y1 \CRNO 
  z_2   = z_1 + \fracL \, (1 + p_z1)^22 \, p_r^3 \, 
                   \left[ \left( p_x1 + \frack_s2 \, y_1 \right)^2 +
                          \left( p_y1 - \frack_s2 \, x_1 \right)^2 \right] \CRNO
  p_z2= p_z1 \nonumber
where k_s = B/P_0 is the normalized field and
  c= \cos \left( k_s L / p_r \right) \CRNO
  s= \sin \left( k_s L / p_r \right)
with
  p_r = \sqrt(1 + p_z)^2 - (p_x + y_1 \, k_s/2)^2 - (p_y - x_1 \, k_s/2)^2

To be useful, the canonical momenta p_x and p_y in the above equations must be connected to the
canonical momenta used for other elements (drifts, quadrupoles, etc.) that may be placed to either
side of the solenoid. These side elements use zero a_x and a_y (cf. \Eqpmc2pc). The vector
potential used in the solenoid canonical momenta may be made zero at the edges of the solenoid if
the solenoid fringe field is assumed to end abruptly at the edges of the solenoid (as shown in
\figf:solenoid), and the reference axis z-axis (at x = y = 0) is placed along the
centerline of the solenoid so that there is cylindrical symmetry around the z-axis.

###section Sprint Spin Tracking

The "sprint" spin tracking method is named after the "SPRINT" program developed by Matthias
Vogt.  The "sprint" algorithm Uses a first order spin map evaluated with respect to the zero
orbit to track through elements. This method is much faster than PTC integration, and its run-time
does not increase proportionally to element length. Currently, the supported lattice elements are
bends (including bends with k_1 \neq 0), quadrupoles, and solenoids.

Elements with fringe field contributions are split into three quaternions representing the entrance,
body, and exit of the element. Before propagation, the exit fringe quaternion is always equivalent
to the entrance fringe quaternion, with all field strengths multiplied by -1, and e_1 replaced
with -e_2. The exit quaternion is then propagated to the end of the element via Bmad mapping
tools. Appropriate quaternions are concatenated according to the values of "spin_fringe_on" and
"fringe_at".

 d  = g \, l             e  = a \, g \, l\gamma  s   = a \, k_s l      t  = (1+a) k_s l         \CRNO
 c_d= \cos(d)    \qquad& s_e2&= \sin(\frace2)& c_s&= \cos(s) \qquad& c_t= \cos(t)           
 s_d= \sin(d)          c_e2&= \cos(\frace2)& s_s&= \sin(s)       s_t2&= \sin(\fract2) \CRNO
 \chi = 1+a\gamma          \zeta= \gamma - 1   \qquad& \psi= \gamma^2 - 1    c_t2&= \cos(\fract2) \nonumber

###subsection SBend Body, k_1 = 0

        q_0    q_y     q_z  
  1   c_e2 -s_e2        \addlinespace[1ex]
  x   -\frac12 g \chi s_d s_e2 -\frac12 g \chi \, s_d c_e2  \addlinespace[1ex]
  p_x \frac12 \chi \, (c_d - 1)  s_e2 \frac12 \chi \, (c_d - 1) c_e2  \addlinespace[1ex]
  p_y                    \frac1\gamma \zeta \, s_e2  \addlinespace[1ex]
  p_z \frac12 \gamma \left(\gamma \, \chi \, s_d -a \, \psi \, d \right) s_e2 
  
###subsection Sbend Body, k_1 \neq 0

   k_x = k_1 + g^2 
  \omega_x = \sqrt|k_x| 
  \omega_y = \sqrt|k_1|
\qquad\qquad\qquad
  \alpha = 2(a^2 g^2 \gamma^2 + k_1)  \nonumber
  \beta = a g k_1 (\gamma \chi - \zeta)  \nonumber
  \sigma = \omega_y (k_1 + a k_1 \gamma + a^2g^2 \zeta \gamma) \nonumber
  \xi = \omega_y (k_1 \chi + a^2 g^2 \zeta \gamma) \nonumber

  k_x > 0                  k_x < 0              k_1 > 0                   k_1 < 0  
  s_x = \sin(l \omega_x)  \sinh(l \omega_x) s_y = \sinh(l \omega_y)  \sin(l \omega_y) 
  c_x = \cos(l \omega_x)  \cosh(l \omega_x) c_y = \cosh(l \omega_y)  \cos(l \omega_y) 
  \tau_x = -1              +1                   \tau_y = +1               -1

        q_0    q_x q_y     q_z  
  1     c_e2       -s_e2        \addlinespace[1ex]
  x   \frac-k_x \chi2 \omega_x s_x s_e2             
    \frac-k_x \chi2 \omega_x s_x c_e2  \addlinespace[1ex]
  p_x \frack_x \chi2\omega_x^2 \tau_x (1-c_x) s_e2  
    \frack_x \chi2 \omega_x^2 \tau_x \left(1-c_x\right) c_e2  \addlinespace[1ex]
  y           
    \beginaligned
      \frac-1\alpha\bigl[ \beta (1+ c_y) s_e2 + [-1.5ex]
      \hskip4.5em \tau_y \sigma s_y c_e2 \bigr]
    \beginaligned
       \frac1\alpha\bigl[ \beta (1-c_y) c_e2 +  [-1.5ex]
       \hskip4.5em \tau_y \sigma s_y s_e2 \bigr]
  p_y         
    \beginaligned
      \frac1\omega_y \alpha\bigl[ \xi (1 - c_y) c_e2 -  [-1.5ex]
      \hskip5em \beta s_y s_e2 \bigr]
    \beginaligned
      \frac1\omega_y \alpha\bigl[ \xi (1+c_y) s_e2 -  [-1.5ex]
      \hskip5em \beta s_y c_e2\bigr]
  p_z \fracg2\left(\frac\chi s_x\omega_x - \fraca l \psi\gamma\right) s_e2   
    \fracg2\left(\frac\chi s_x\omega_x - \fraca l \psi\gamma\right) c_e2 
  
###subsection Sbend Entrance Fringe

To calculate the exit fringe, multiply all field strengths g by
-1, and replace all entrance face angles e_1 with exit face angles -e_2. The negative exit face
angle is used due to Bmad convention.
      q_0 q_x                         q_y                          q_z  
  1   1                                                                   \addlinespace[1ex]
  x                                     \frac12 \chi g \tan(e_1)  \addlinespace[1ex]
  y       \frac12(1+a)g \sin(e_1)                                -\frac12(1+a)g \cos(e_1) 
  
###subsection Quadrupole

  \omega = \sqrt|k_1| \nonumber

  k_1 > 0 k_1 < 0 k_1 > 0 k_1 < 0  
  s_x = \frac\sin(l \omega)\omega  \frac\sinh(l \omega)\omegas_y = \frac\sinh(l \omega)\omega  \frac\sin(l \omega)\omega 
  c_x = \frac1 - \cos(l \omega)\omega^2  \frac-1 + \cosh(l \omega)\omega^2c_y = \frac-1 + \cosh(l \omega)\omega^2  \frac1 - \cos(l \omega)\omega^2 
\everymath

        q_0 q_x q_y  
  1     1                  \addlinespace[1ex]
  x               -\frac12 k_1 \chi s_x  \addlinespace[1ex]
  p_x             -\frac12 k_1 \chi c_x  \addlinespace[1ex]
  y         -\frac12 k_1 \chi s_y  \addlinespace[1ex]
  p_y       -\frac12 k_1 \chi c_y 

###subsection Solenoid Element Body

   q_0 q_x q_y q_z  
  1 c_t2 -s_t2  \addlinespace[1ex]
  x \frac14 k_s \zeta ((1 - c_s) c_t2 - s_s s_t2) \frac14 k_s \zeta ((-1 + c_s) s_t2 - s_s c_t2)  \addlinespace[1ex]
  p_x \frac12 \zeta ((1-c_s) st2 + s_s c_t2) \frac12 \zeta ((1 - c_s) c_t2 - s_s s_t2)  \addlinespace[1ex]
  y \frac14 k_s \zeta ((1 - c_s) s_t2 + s_s c_t2) \frac14 k_s \zeta ((1 - c_s) c_t2 - s_s s_t2) \addlinespace[1ex]
  p_y \frac12 \zeta ((-1 + c_s) c_t2 + s_s s_t2) \frac12 \zeta ((1-c_s) s_t2 + s_s c_t2)  \addlinespace[1ex]
  p_z \frac12 t s_t2 \frac12 t c_t2 

###subsection Solenoid Entrance Fringe
To calculate the exit fringe, multiply all field strengths k_s by -1.
  q_0 q_x q_y  
  1 1 
  x \frac14 k_s \chi   
  y \frac14 k_s \chi  

###section Symplectic Tracking with Cartesian Modes

The method for symplectic integration for elements that define the magnetic field using a
Cartesian mode decomposition  is outlined in.  The
vector potential is constructed to avoid singularities when one of the wave vectors k_x,
k_y, or k_z is zero.

For the "x" "family" the vector potential is:

\setlength\tabcolsep1pt
  Form \; \multicolumn3lhyper-y  \multicolumn3lhyper-xy  \multicolumn3lhyper-x 
  A_x   
    A \dfrack_zk_y^2      \Se_x \, \Sh_y \, \Se_z \qquad
    A \dfrac1k_y          \Sh_x \, \Sh_y \, \Se_z \qquad
    A \dfrack_zk_x \, k_y \Sh_x \, \Se_y \, \Se_z 
  A_y   0&& 0&& 0& 
  A_z   
    A \dfrack_xk_y^2      \Ce_x \, \Sh_y \, \Ce_z \qquad
    A \dfrack_xk_y \, k_z \Ch_x \, \Sh_y \, \Ce_z \qquad
    A \dfrac1k_y          \Ch_x \, \Se_y \, \Ce_z 

For the "y" "family" the vector potential is:

\setlength\tabcolsep1pt
  Form \; \multicolumn3lhyper-y  \multicolumn3lhyper-xy  \multicolumn3lhyper-x 
  A_x   0&& 0&& 0& 
  A_y   
    -A \dfrack_zk_x \, k_y \Se_x \, \Sh_y \, \Se_z \qquad
    -A \dfrac1k_x          \Sh_x \, \Sh_y \, \Se_z \qquad
    -A \dfrack_zk_x^2      \Sh_x \, \Se_y \, \Se_z 
  A_z   
    -A \dfrac1k_x          \Se_x \, \Ch_y \, \Ce_z \qquad
    -A \dfrack_yk_x \, k_z \Sh_x \, \Ch_y \, \Ce_z \qquad
    -A \dfrack_yk_x^2      \Sh_x \, \Ce_y \, \Ce_z 

For the "qu" "family" the vector potential is:

\setlength\tabcolsep1pt
  Form \; \multicolumn3lhyper-y  \multicolumn3lhyper-xy  \multicolumn3lhyper-x 
  A_x   
     A \dfrac1k_z          \Se_x \, \Ch_y \, \Se_z \qquad
     A \dfrack_yk_z^2      \Sh_x \, \Ch_y \, \Se_z \qquad
     A \dfrack_yk_x \, k_z \Sh_x \, \Ce_y \, \Se_z 
  A_y   
    -A \dfrack_xk_y \, k_z \Ce_x \, \Sh_y \, \Se_z \qquad
    -A \dfrack_xk_z^2      \Ch_x \, \Sh_y \, \Se_z \qquad
    -A \dfrac1k_z          \Ch_x \, \Se_y \, \Se_z 
  A_z   0&& 0&& 0&

For the "sq" "family" the vector potential is:

\setlength\tabcolsep1pt
  Form \; \multicolumn3lhyper-y  \multicolumn3lhyper-xy  \multicolumn3lhyper-x 
  A_x   
     A \dfrac1k_z          \Ce_x \, \Sh_y \, \Se_z \qquad
     A \dfrack_yk_z^2      \Ch_x \, \Sh_y \, \Se_z \qquad
     A \dfrack_yk_x \, k_z \Ch_x \, \Se_y \, \Se_z 
  A_y   
     A \dfrack_xk_y \, k_z \Se_x \, \Ch_y \, \Se_z \qquad
    -A \dfrack_xk_z^2      \Sh_x \, \Ch_y \, \Se_z \qquad
     A \dfrac1k_z          \Sh_x \, \Ce_y \, \Se_z 
  A_z   0&& 0&& 0&

